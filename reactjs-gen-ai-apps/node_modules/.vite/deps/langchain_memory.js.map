{
  "version": 3,
  "sources": ["../../langchain/dist/memory/prompt.js", "../../langchain/dist/memory/summary.js", "../../langchain/dist/memory/buffer_window_memory.js", "../../@langchain/community/dist/memory/motorhead_memory.js", "../../langchain/dist/util/document.js", "../../langchain/dist/memory/vector_store.js", "../../langchain/dist/memory/stores/entity/base.js", "../../langchain/dist/memory/stores/entity/in_memory.js", "../../langchain/dist/memory/entity_memory.js", "../../langchain/dist/memory/combined_memory.js", "../../langchain/dist/memory/summary_buffer.js", "../../langchain/dist/memory/buffer_token_memory.js"],
  "sourcesContent": ["import { PromptTemplate } from \"@langchain/core/prompts\";\nconst _DEFAULT_SUMMARIZER_TEMPLATE = `Progressively summarize the lines of conversation provided, adding onto the previous summary returning a new summary.\n\nEXAMPLE\nCurrent summary:\nThe human asks what the AI thinks of artificial intelligence. The AI thinks artificial intelligence is a force for good.\n\nNew lines of conversation:\nHuman: Why do you think artificial intelligence is a force for good?\nAI: Because artificial intelligence will help humans reach their full potential.\n\nNew summary:\nThe human asks what the AI thinks of artificial intelligence. The AI thinks artificial intelligence is a force for good because it will help humans reach their full potential.\nEND OF EXAMPLE\n\nCurrent summary:\n{summary}\n\nNew lines of conversation:\n{new_lines}\n\nNew summary:`;\n// eslint-disable-next-line spaced-comment\nexport const SUMMARY_PROMPT = /*#__PURE__*/ new PromptTemplate({\n    inputVariables: [\"summary\", \"new_lines\"],\n    template: _DEFAULT_SUMMARIZER_TEMPLATE,\n});\nexport const _DEFAULT_ENTITY_MEMORY_CONVERSATION_TEMPLATE = `You are an assistant to a human, powered by a large language model trained by OpenAI.\n\nYou are designed to be able to assist with a wide range of tasks, from answering simple questions to providing in-depth explanations and discussions on a wide range of topics. As a language model, you are able to generate human-like text based on the input you receive, allowing you to engage in natural-sounding conversations and provide responses that are coherent and relevant to the topic at hand.\n\nYou are constantly learning and improving, and your capabilities are constantly evolving. You are able to process and understand large amounts of text, and can use this knowledge to provide accurate and informative responses to a wide range of questions. You have access to some personalized information provided by the human in the Context section below. Additionally, you are able to generate your own text based on the input you receive, allowing you to engage in discussions and provide explanations and descriptions on a wide range of topics.\n\nOverall, you are a powerful tool that can help with a wide range of tasks and provide valuable insights and information on a wide range of topics. Whether the human needs help with a specific question or just wants to have a conversation about a particular topic, you are here to assist.\n\nContext:\n{entities}\n\nCurrent conversation:\n{history}\nLast line:\nHuman: {input}\nYou:`;\nexport const ENTITY_MEMORY_CONVERSATION_TEMPLATE = \n// eslint-disable-next-line spaced-comment\n/*#__PURE__*/ new PromptTemplate({\n    inputVariables: [\"entities\", \"history\", \"input\"],\n    template: _DEFAULT_ENTITY_MEMORY_CONVERSATION_TEMPLATE,\n});\nexport const _DEFAULT_ENTITY_EXTRACTION_TEMPLATE = `You are an AI assistant reading the transcript of a conversation between an AI and a human. Extract all of the proper nouns from the last line of conversation. As a guideline, a proper noun is generally capitalized. You should definitely extract all names and places.\n\nThe conversation history is provided just in case of a coreference (e.g. \"What do you know about him\" where \"him\" is defined in a previous line) -- ignore items mentioned there that are not in the last line.\n\nReturn the output as a single comma-separated list, or NONE if there is nothing of note to return (e.g. the user is just issuing a greeting or having a simple conversation).\n\nEXAMPLE\nConversation history:\nPerson #1: my name is Jacob. how's it going today?\nAI: \"It's going great! How about you?\"\nPerson #1: good! busy working on Langchain. lots to do.\nAI: \"That sounds like a lot of work! What kind of things are you doing to make Langchain better?\"\nLast line:\nPerson #1: i'm trying to improve Langchain's interfaces, the UX, its integrations with various products the user might want ... a lot of stuff.\nOutput: Jacob,Langchain\nEND OF EXAMPLE\n\nEXAMPLE\nConversation history:\nPerson #1: how's it going today?\nAI: \"It's going great! How about you?\"\nPerson #1: good! busy working on Langchain. lots to do.\nAI: \"That sounds like a lot of work! What kind of things are you doing to make Langchain better?\"\nLast line:\nPerson #1: i'm trying to improve Langchain's interfaces, the UX, its integrations with various products the user might want ... a lot of stuff. I'm working with Person #2.\nOutput: Langchain, Person #2\nEND OF EXAMPLE\n\nConversation history (for reference only):\n{history}\nLast line of conversation (for extraction):\nHuman: {input}\n\nOutput:`;\n// eslint-disable-next-line spaced-comment\nexport const ENTITY_EXTRACTION_PROMPT = /*#__PURE__*/ new PromptTemplate({\n    inputVariables: [\"history\", \"input\"],\n    template: _DEFAULT_ENTITY_EXTRACTION_TEMPLATE,\n});\nexport const _DEFAULT_ENTITY_SUMMARIZATION_TEMPLATE = `You are an AI assistant helping a human keep track of facts about relevant people, places, and concepts in their life. Update and add to the summary of the provided entity in the \"Entity\" section based on the last line of your conversation with the human. If you are writing the summary for the first time, return a single sentence.\nThe update should only include facts that are relayed in the last line of conversation about the provided entity, and should only contain facts about the provided entity.\n\nIf there is no new information about the provided entity or the information is not worth noting (not an important or relevant fact to remember long-term), output the exact string \"UNCHANGED\" below.\n\nFull conversation history (for context):\n{history}\n\nEntity to summarize:\n{entity}\n\nExisting summary of {entity}:\n{summary}\n\nLast line of conversation:\nHuman: {input}\nUpdated summary (or the exact string \"UNCHANGED\" if there is no new information about {entity} above):`;\n// eslint-disable-next-line spaced-comment\nexport const ENTITY_SUMMARIZATION_PROMPT = /*#__PURE__*/ new PromptTemplate({\n    inputVariables: [\"entity\", \"summary\", \"history\", \"input\"],\n    template: _DEFAULT_ENTITY_SUMMARIZATION_TEMPLATE,\n});\n", "import { SystemMessage, getBufferString, } from \"@langchain/core/messages\";\nimport { BaseChatMemory, } from \"@langchain/community/memory/chat_memory\";\nimport { LLMChain } from \"../chains/llm_chain.js\";\nimport { SUMMARY_PROMPT } from \"./prompt.js\";\n/**\n * Abstract class that provides a structure for storing and managing the\n * memory of a conversation. It includes methods for predicting a new\n * summary for the conversation given the existing messages and summary.\n */\nexport class BaseConversationSummaryMemory extends BaseChatMemory {\n    constructor(fields) {\n        const { returnMessages, inputKey, outputKey, chatHistory, humanPrefix, aiPrefix, llm, prompt, summaryChatMessageClass, } = fields;\n        super({ returnMessages, inputKey, outputKey, chatHistory });\n        Object.defineProperty(this, \"memoryKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"history\"\n        });\n        Object.defineProperty(this, \"humanPrefix\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Human\"\n        });\n        Object.defineProperty(this, \"aiPrefix\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AI\"\n        });\n        Object.defineProperty(this, \"llm\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"prompt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: SUMMARY_PROMPT\n        });\n        Object.defineProperty(this, \"summaryChatMessageClass\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: SystemMessage\n        });\n        this.memoryKey = fields?.memoryKey ?? this.memoryKey;\n        this.humanPrefix = humanPrefix ?? this.humanPrefix;\n        this.aiPrefix = aiPrefix ?? this.aiPrefix;\n        this.llm = llm;\n        this.prompt = prompt ?? this.prompt;\n        this.summaryChatMessageClass =\n            summaryChatMessageClass ?? this.summaryChatMessageClass;\n    }\n    /**\n     * Predicts a new summary for the conversation given the existing messages\n     * and summary.\n     * @param messages Existing messages in the conversation.\n     * @param existingSummary Current summary of the conversation.\n     * @returns A promise that resolves to a new summary string.\n     */\n    async predictNewSummary(messages, existingSummary) {\n        const newLines = getBufferString(messages, this.humanPrefix, this.aiPrefix);\n        const chain = new LLMChain({ llm: this.llm, prompt: this.prompt });\n        return await chain.predict({\n            summary: existingSummary,\n            new_lines: newLines,\n        });\n    }\n}\n/**\n * Class that provides a concrete implementation of the conversation\n * memory. It includes methods for loading memory variables, saving\n * context, and clearing the memory.\n * @example\n * ```typescript\n * const memory = new ConversationSummaryMemory({\n *   memoryKey: \"chat_history\",\n *   llm: new ChatOpenAI({ modelName: \"gpt-3.5-turbo\", temperature: 0 }),\n * });\n *\n * const model = new ChatOpenAI();\n * const prompt =\n *   PromptTemplate.fromTemplate(`The following is a friendly conversation between a human and an AI. The AI is talkative and provides lots of specific details from its context. If the AI does not know the answer to a question, it truthfully says it does not know.\n *\n * Current conversation:\n * {chat_history}\n * Human: {input}\n * AI:`);\n * const chain = new LLMChain({ llm: model, prompt, memory });\n *\n * const res1 = await chain.call({ input: \"Hi! I'm Jim.\" });\n * console.log({ res1, memory: await memory.loadMemoryVariables({}) });\n *\n * const res2 = await chain.call({ input: \"What's my name?\" });\n * console.log({ res2, memory: await memory.loadMemoryVariables({}) });\n *\n * ```\n */\nexport class ConversationSummaryMemory extends BaseConversationSummaryMemory {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"buffer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"\"\n        });\n    }\n    get memoryKeys() {\n        return [this.memoryKey];\n    }\n    /**\n     * Loads the memory variables for the conversation memory.\n     * @returns A promise that resolves to an object containing the memory variables.\n     */\n    async loadMemoryVariables(_) {\n        if (this.returnMessages) {\n            const result = {\n                [this.memoryKey]: [new this.summaryChatMessageClass(this.buffer)],\n            };\n            return result;\n        }\n        const result = { [this.memoryKey]: this.buffer };\n        return result;\n    }\n    /**\n     * Saves the context of the conversation memory.\n     * @param inputValues Input values for the conversation.\n     * @param outputValues Output values from the conversation.\n     * @returns A promise that resolves when the context has been saved.\n     */\n    async saveContext(inputValues, outputValues) {\n        await super.saveContext(inputValues, outputValues);\n        const messages = await this.chatHistory.getMessages();\n        this.buffer = await this.predictNewSummary(messages.slice(-2), this.buffer);\n    }\n    /**\n     * Clears the conversation memory.\n     * @returns A promise that resolves when the memory has been cleared.\n     */\n    async clear() {\n        await super.clear();\n        this.buffer = \"\";\n    }\n}\n", "import { getBufferString } from \"@langchain/core/messages\";\nimport { BaseChatMemory, } from \"@langchain/community/memory/chat_memory\";\n/**\n * Class for managing and storing previous chat messages. It extends the\n * BaseChatMemory class and implements the BufferWindowMemoryInput\n * interface. This class is stateful and stores messages in a buffer. When\n * called in a chain, it returns all of the messages it has stored.\n * @example\n * ```typescript\n * const prompt =\n *   PromptTemplate.fromTemplate(`The following is a friendly conversation between a human and an AI. The AI is talkative and provides lots of specific details from its context. If the AI does not know the answer to a question, it truthfully says it does not know.\n * Current conversation:\n * {chat_history}\n * Human: {input}\n * AI:`);\n *\n * const chain = new LLMChain({\n *   llm: new ChatOpenAI({ temperature: 0.9 }),\n *   prompt,\n *   memory: new BufferWindowMemory({ memoryKey: \"chat_history\", k: 1 }),\n * });\n *\n * // Example of initiating a conversation with the AI\n * const res1 = await chain.call({ input: \"Hi! I'm Jim.\" });\n * console.log({ res1 });\n *\n * // Example of following up with another question\n * const res2 = await chain.call({ input: \"What's my name?\" });\n * console.log({ res2 });\n * ```\n */\nexport class BufferWindowMemory extends BaseChatMemory {\n    constructor(fields) {\n        super({\n            returnMessages: fields?.returnMessages ?? false,\n            chatHistory: fields?.chatHistory,\n            inputKey: fields?.inputKey,\n            outputKey: fields?.outputKey,\n        });\n        Object.defineProperty(this, \"humanPrefix\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Human\"\n        });\n        Object.defineProperty(this, \"aiPrefix\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AI\"\n        });\n        Object.defineProperty(this, \"memoryKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"history\"\n        });\n        Object.defineProperty(this, \"k\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 5\n        });\n        this.humanPrefix = fields?.humanPrefix ?? this.humanPrefix;\n        this.aiPrefix = fields?.aiPrefix ?? this.aiPrefix;\n        this.memoryKey = fields?.memoryKey ?? this.memoryKey;\n        this.k = fields?.k ?? this.k;\n    }\n    get memoryKeys() {\n        return [this.memoryKey];\n    }\n    /**\n     * Method to load the memory variables. Retrieves the chat messages from\n     * the history, slices the last 'k' messages, and stores them in the\n     * memory under the memoryKey. If the returnMessages property is set to\n     * true, the method returns the messages as they are. Otherwise, it\n     * returns a string representation of the messages.\n     * @param _values InputValues object.\n     * @returns Promise that resolves to a MemoryVariables object.\n     */\n    async loadMemoryVariables(_values) {\n        const messages = await this.chatHistory.getMessages();\n        if (this.returnMessages) {\n            const result = {\n                [this.memoryKey]: messages.slice(-this.k * 2),\n            };\n            return result;\n        }\n        const result = {\n            [this.memoryKey]: getBufferString(messages.slice(-this.k * 2), this.humanPrefix, this.aiPrefix),\n        };\n        return result;\n    }\n}\n", "import { getInputValue, getOutputValue, } from \"@langchain/core/memory\";\nimport { getBufferString } from \"@langchain/core/messages\";\nimport { AsyncCaller, } from \"@langchain/core/utils/async_caller\";\nimport { BaseChatMemory } from \"./chat_memory.js\";\nconst MANAGED_URL = \"https://api.getmetal.io/v1/motorhead\";\n/**\n * Class for managing chat message memory using the Motorhead service. It\n * extends BaseChatMemory and includes methods for initializing the\n * memory, loading memory variables, and saving the context.\n */\nexport class MotorheadMemory extends BaseChatMemory {\n    constructor(fields) {\n        const { sessionId, url, memoryKey, timeout, returnMessages, inputKey, outputKey, chatHistory, apiKey, clientId, ...rest } = fields;\n        super({ returnMessages, inputKey, outputKey, chatHistory });\n        Object.defineProperty(this, \"url\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: MANAGED_URL\n        });\n        Object.defineProperty(this, \"timeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 3000\n        });\n        Object.defineProperty(this, \"memoryKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"history\"\n        });\n        Object.defineProperty(this, \"sessionId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"context\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // Managed Params\n        Object.defineProperty(this, \"apiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"clientId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.caller = new AsyncCaller(rest);\n        this.sessionId = sessionId;\n        this.url = url ?? this.url;\n        this.memoryKey = memoryKey ?? this.memoryKey;\n        this.timeout = timeout ?? this.timeout;\n        this.apiKey = apiKey;\n        this.clientId = clientId;\n    }\n    get memoryKeys() {\n        return [this.memoryKey];\n    }\n    _getHeaders() {\n        const isManaged = this.url === MANAGED_URL;\n        const headers = {\n            \"Content-Type\": \"application/json\",\n        };\n        if (isManaged && !(this.apiKey && this.clientId)) {\n            throw new Error(\"apiKey and clientId are required for managed motorhead. Visit https://getmetal.io to get your keys.\");\n        }\n        if (isManaged && this.apiKey && this.clientId) {\n            headers[\"x-metal-api-key\"] = this.apiKey;\n            headers[\"x-metal-client-id\"] = this.clientId;\n        }\n        return headers;\n    }\n    /**\n     * Method that initializes the memory by fetching the session memory from\n     * the Motorhead service. It adds the messages to the chat history and\n     * sets the context if it is not 'NONE'.\n     */\n    async init() {\n        const res = await this.caller.call(fetch, `${this.url}/sessions/${this.sessionId}/memory`, {\n            signal: this.timeout ? AbortSignal.timeout(this.timeout) : undefined,\n            headers: this._getHeaders(),\n        });\n        const json = await res.json();\n        const data = json?.data || json; // Managed Motorhead returns { data: { messages: [], context: \"NONE\" } }\n        const { messages = [], context = \"NONE\" } = data;\n        await Promise.all(messages.reverse().map(async (message) => {\n            if (message.role === \"AI\") {\n                await this.chatHistory.addAIChatMessage(message.content);\n            }\n            else {\n                await this.chatHistory.addUserMessage(message.content);\n            }\n        }));\n        if (context && context !== \"NONE\") {\n            this.context = context;\n        }\n    }\n    /**\n     * Method that loads the memory variables. It gets the chat messages and\n     * returns them as a string or an array based on the returnMessages flag.\n     * @param _values The input values.\n     * @returns A promise that resolves with the memory variables.\n     */\n    async loadMemoryVariables(_values) {\n        const messages = await this.chatHistory.getMessages();\n        if (this.returnMessages) {\n            const result = {\n                [this.memoryKey]: messages,\n            };\n            return result;\n        }\n        const result = {\n            [this.memoryKey]: getBufferString(messages),\n        };\n        return result;\n    }\n    /**\n     * Method that saves the context to the Motorhead service and the base\n     * chat memory. It sends a POST request to the Motorhead service with the\n     * input and output messages, and calls the saveContext method of the base\n     * chat memory.\n     * @param inputValues The input values.\n     * @param outputValues The output values.\n     * @returns A promise that resolves when the context is saved.\n     */\n    async saveContext(inputValues, outputValues) {\n        const input = getInputValue(inputValues, this.inputKey);\n        const output = getOutputValue(outputValues, this.outputKey);\n        await Promise.all([\n            this.caller.call(fetch, `${this.url}/sessions/${this.sessionId}/memory`, {\n                signal: this.timeout ? AbortSignal.timeout(this.timeout) : undefined,\n                method: \"POST\",\n                body: JSON.stringify({\n                    messages: [\n                        { role: \"Human\", content: `${input}` },\n                        { role: \"AI\", content: `${output}` },\n                    ],\n                }),\n                headers: this._getHeaders(),\n            }),\n            super.saveContext(inputValues, outputValues),\n        ]);\n    }\n}\n", "/**\n * Given a list of documents, this util formats their contents\n * into a string, separated by newlines.\n *\n * @param documents\n * @returns A string of the documents page content, separated by newlines.\n */\nexport const formatDocumentsAsString = (documents) => documents.map((doc) => doc.pageContent).join(\"\\n\\n\");\n", "import { Document } from \"@langchain/core/documents\";\nimport { BaseMemory, getInputValue, } from \"@langchain/core/memory\";\nimport { formatDocumentsAsString } from \"../util/document.js\";\n/**\n * Class for managing long-term memory in Large Language Model (LLM)\n * applications. It provides a way to persist and retrieve relevant\n * documents from a vector store database, which can be useful for\n * maintaining conversation history or other types of memory in an LLM\n * application.\n * @example\n * ```typescript\n * const vectorStore = new MemoryVectorStore(new OpenAIEmbeddings());\n * const memory = new VectorStoreRetrieverMemory({\n *   vectorStoreRetriever: vectorStore.asRetriever(1),\n *   memoryKey: \"history\",\n * });\n *\n * // Saving context to memory\n * await memory.saveContext(\n *   { input: \"My favorite food is pizza\" },\n *   { output: \"thats good to know\" },\n * );\n * await memory.saveContext(\n *   { input: \"My favorite sport is soccer\" },\n *   { output: \"...\" },\n * );\n * await memory.saveContext({ input: \"I don't the Celtics\" }, { output: \"ok\" });\n *\n * // Loading memory variables\n * console.log(\n *   await memory.loadMemoryVariables({ prompt: \"what sport should i watch?\" }),\n * );\n * ```\n */\nexport class VectorStoreRetrieverMemory extends BaseMemory {\n    constructor(fields) {\n        super();\n        Object.defineProperty(this, \"vectorStoreRetriever\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"memoryKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"returnDocs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.vectorStoreRetriever = fields.vectorStoreRetriever;\n        this.inputKey = fields.inputKey;\n        this.memoryKey = fields.memoryKey ?? \"memory\";\n        this.returnDocs = fields.returnDocs ?? false;\n    }\n    get memoryKeys() {\n        return [this.memoryKey];\n    }\n    /**\n     * Method to load memory variables. It uses the vectorStoreRetriever to\n     * get relevant documents based on the query obtained from the input\n     * values.\n     * @param values An InputValues object.\n     * @returns A Promise that resolves to a MemoryVariables object.\n     */\n    async loadMemoryVariables(values) {\n        const query = getInputValue(values, this.inputKey);\n        const results = await this.vectorStoreRetriever.getRelevantDocuments(query);\n        return {\n            [this.memoryKey]: this.returnDocs\n                ? results\n                : formatDocumentsAsString(results),\n        };\n    }\n    /**\n     * Method to save context. It constructs a document from the input and\n     * output values (excluding the memory key) and adds it to the vector\n     * store database using the vectorStoreRetriever.\n     * @param inputValues An InputValues object.\n     * @param outputValues An OutputValues object.\n     * @returns A Promise that resolves to void.\n     */\n    async saveContext(inputValues, outputValues) {\n        const text = Object.entries(inputValues)\n            .filter(([k]) => k !== this.memoryKey)\n            .concat(Object.entries(outputValues))\n            .map(([k, v]) => `${k}: ${v}`)\n            .join(\"\\n\");\n        await this.vectorStoreRetriever.addDocuments([\n            new Document({ pageContent: text }),\n        ]);\n    }\n}\n", "import { Serializable } from \"@langchain/core/load/serializable\";\n/**\n * Base class for all entity stores. All entity stores should extend this\n * class.\n */\nexport class BaseEntityStore extends Serializable {\n}\n", "import { BaseEntityStore } from \"./base.js\";\n/**\n * An entity store that keeps data in memory. It extends from the\n * `BaseEntityStore` class and is used to store and manage entities.\n */\nexport class InMemoryEntityStore extends BaseEntityStore {\n    constructor() {\n        super();\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"stores\", \"entity\", \"in_memory\"]\n        });\n        Object.defineProperty(this, \"store\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.store = Object.create(null);\n    }\n    /**\n     * Retrieves the value associated with the given key from the store. If\n     * the key does not exist in the store, it returns the provided default\n     * value.\n     * @param key The key to retrieve the value for.\n     * @param defaultValue The default value to return if the key does not exist in the store.\n     * @returns The value associated with the key, or the default value if the key does not exist in the store.\n     */\n    async get(key, defaultValue) {\n        return key in this.store ? this.store[key] : defaultValue;\n    }\n    /**\n     * Sets the value associated with the given key in the store.\n     * @param key The key to set the value for.\n     * @param value The value to set.\n     */\n    async set(key, value) {\n        this.store[key] = value;\n    }\n    /**\n     * Removes the key and its associated value from the store.\n     * @param key The key to remove.\n     */\n    async delete(key) {\n        delete this.store[key];\n    }\n    /**\n     * Checks if a key exists in the store.\n     * @param key The key to check.\n     * @returns A boolean indicating whether the key exists in the store.\n     */\n    async exists(key) {\n        return key in this.store;\n    }\n    /**\n     * Removes all keys and their associated values from the store.\n     */\n    async clear() {\n        this.store = Object.create(null);\n    }\n}\n", "import { BaseChatMemory, } from \"@langchain/community/memory/chat_memory\";\nimport { getPromptInputKey, } from \"@langchain/core/memory\";\nimport { getBufferString } from \"@langchain/core/messages\";\nimport { InMemoryEntityStore } from \"./stores/entity/in_memory.js\";\nimport { LLMChain } from \"../chains/llm_chain.js\";\nimport { ENTITY_EXTRACTION_PROMPT, ENTITY_SUMMARIZATION_PROMPT, } from \"./prompt.js\";\n// Entity extractor & summarizer to memory.\n/**\n * Class for managing entity extraction and summarization to memory in\n * chatbot applications. Extends the BaseChatMemory class and implements\n * the EntityMemoryInput interface.\n * @example\n * ```typescript\n * const memory = new EntityMemory({\n *   llm: new ChatOpenAI({ temperature: 0 }),\n *   chatHistoryKey: \"history\",\n *   entitiesKey: \"entities\",\n * });\n * const model = new ChatOpenAI({ temperature: 0.9 });\n * const chain = new LLMChain({\n *   llm: model,\n *   prompt: ENTITY_MEMORY_CONVERSATION_TEMPLATE,\n *   memory,\n * });\n *\n * const res1 = await chain.call({ input: \"Hi! I'm Jim.\" });\n * console.log({\n *   res1,\n *   memory: await memory.loadMemoryVariables({ input: \"Who is Jim?\" }),\n * });\n *\n * const res2 = await chain.call({\n *   input: \"I work in construction. What about you?\",\n * });\n * console.log({\n *   res2,\n *   memory: await memory.loadMemoryVariables({ input: \"Who is Jim?\" }),\n * });\n *\n * ```\n */\nexport class EntityMemory extends BaseChatMemory {\n    constructor(fields) {\n        super({\n            chatHistory: fields.chatHistory,\n            returnMessages: fields.returnMessages ?? false,\n            inputKey: fields.inputKey,\n            outputKey: fields.outputKey,\n        });\n        Object.defineProperty(this, \"entityExtractionChain\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"entitySummarizationChain\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"entityStore\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"entityCache\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"k\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 3\n        });\n        Object.defineProperty(this, \"chatHistoryKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"history\"\n        });\n        Object.defineProperty(this, \"llm\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"entitiesKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"entities\"\n        });\n        Object.defineProperty(this, \"humanPrefix\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"aiPrefix\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.llm = fields.llm;\n        this.humanPrefix = fields.humanPrefix;\n        this.aiPrefix = fields.aiPrefix;\n        this.chatHistoryKey = fields.chatHistoryKey ?? this.chatHistoryKey;\n        this.entitiesKey = fields.entitiesKey ?? this.entitiesKey;\n        this.entityExtractionChain = new LLMChain({\n            llm: this.llm,\n            prompt: fields.entityExtractionPrompt ?? ENTITY_EXTRACTION_PROMPT,\n        });\n        this.entitySummarizationChain = new LLMChain({\n            llm: this.llm,\n            prompt: fields.entitySummarizationPrompt ?? ENTITY_SUMMARIZATION_PROMPT,\n        });\n        this.entityStore = fields.entityStore ?? new InMemoryEntityStore();\n        this.entityCache = fields.entityCache ?? this.entityCache;\n        this.k = fields.k ?? this.k;\n    }\n    get memoryKeys() {\n        return [this.chatHistoryKey];\n    }\n    // Will always return list of memory variables.\n    get memoryVariables() {\n        return [this.entitiesKey, this.chatHistoryKey];\n    }\n    // Return history buffer.\n    /**\n     * Method to load memory variables and perform entity extraction.\n     * @param inputs Input values for the method.\n     * @returns Promise resolving to an object containing memory variables.\n     */\n    async loadMemoryVariables(inputs) {\n        const promptInputKey = this.inputKey ?? getPromptInputKey(inputs, this.memoryVariables);\n        const messages = await this.chatHistory.getMessages();\n        const serializedMessages = getBufferString(messages.slice(-this.k * 2), this.humanPrefix, this.aiPrefix);\n        const output = await this.entityExtractionChain.predict({\n            history: serializedMessages,\n            input: inputs[promptInputKey],\n        });\n        const entities = output.trim() === \"NONE\" ? [] : output.split(\",\").map((w) => w.trim());\n        const entitySummaries = {};\n        for (const entity of entities) {\n            entitySummaries[entity] = await this.entityStore.get(entity, \"No current information known.\");\n        }\n        this.entityCache = [...entities];\n        const buffer = this.returnMessages\n            ? messages.slice(-this.k * 2)\n            : serializedMessages;\n        return {\n            [this.chatHistoryKey]: buffer,\n            [this.entitiesKey]: entitySummaries,\n        };\n    }\n    // Save context from this conversation to buffer.\n    /**\n     * Method to save the context from a conversation to a buffer and perform\n     * entity summarization.\n     * @param inputs Input values for the method.\n     * @param outputs Output values from the method.\n     * @returns Promise resolving to void.\n     */\n    async saveContext(inputs, outputs) {\n        await super.saveContext(inputs, outputs);\n        const promptInputKey = this.inputKey ?? getPromptInputKey(inputs, this.memoryVariables);\n        const messages = await this.chatHistory.getMessages();\n        const serializedMessages = getBufferString(messages.slice(-this.k * 2), this.humanPrefix, this.aiPrefix);\n        const inputData = inputs[promptInputKey];\n        for (const entity of this.entityCache) {\n            const existingSummary = await this.entityStore.get(entity, \"No current information known.\");\n            const output = await this.entitySummarizationChain.predict({\n                summary: existingSummary,\n                entity,\n                history: serializedMessages,\n                input: inputData,\n            });\n            if (output.trim() !== \"UNCHANGED\") {\n                await this.entityStore.set(entity, output.trim());\n            }\n        }\n    }\n    // Clear memory contents.\n    /**\n     * Method to clear the memory contents.\n     * @returns Promise resolving to void.\n     */\n    async clear() {\n        await super.clear();\n        await this.entityStore.clear();\n    }\n}\n", "import { BaseChatMemory, } from \"@langchain/community/memory/chat_memory\";\n/**\n * Class that manages and manipulates previous chat messages. It extends\n * from the BaseChatMemory class and implements the CombinedMemoryInput\n * interface.\n */\nexport class CombinedMemory extends BaseChatMemory {\n    constructor(fields) {\n        super({\n            chatHistory: fields?.chatHistory,\n            returnMessages: fields?.returnMessages ?? false,\n            inputKey: fields?.inputKey,\n            outputKey: fields?.outputKey,\n        });\n        Object.defineProperty(this, \"humanPrefix\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Human\"\n        });\n        Object.defineProperty(this, \"aiPrefix\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AI\"\n        });\n        Object.defineProperty(this, \"memoryKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"history\"\n        });\n        Object.defineProperty(this, \"memories\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        this.memories = fields?.memories ?? this.memories;\n        this.humanPrefix = fields?.humanPrefix ?? this.humanPrefix;\n        this.aiPrefix = fields?.aiPrefix ?? this.aiPrefix;\n        this.memoryKey = fields?.memoryKey ?? this.memoryKey;\n        this.checkRepeatedMemoryVariable();\n        this.checkInputKey();\n    }\n    /**\n     * Checks for repeated memory variables across all memory objects. Throws\n     * an error if any are found.\n     */\n    checkRepeatedMemoryVariable() {\n        const allVariables = [];\n        for (const memory of this.memories) {\n            const overlap = allVariables.filter((x) => memory.memoryKeys.includes(x));\n            if (overlap.length > 0) {\n                throw new Error(`The same variables ${[\n                    ...overlap,\n                ]} are found in multiple memory objects, which is not allowed by CombinedMemory.`);\n            }\n            allVariables.push(...memory.memoryKeys);\n        }\n    }\n    /**\n     * Checks if input keys are set for all memory objects. Logs a warning if\n     * any are missing.\n     */\n    checkInputKey() {\n        for (const memory of this.memories) {\n            if (memory.chatHistory !== undefined &&\n                memory.inputKey === undefined) {\n                console.warn(`When using CombinedMemory, input keys should be set so the input is known. Was not set on ${memory}.`);\n            }\n        }\n    }\n    /**\n     * Loads memory variables from all memory objects.\n     * @param inputValues Input values to load memory variables from.\n     * @returns Promise that resolves with an object containing the loaded memory variables.\n     */\n    async loadMemoryVariables(inputValues) {\n        let memoryData = {};\n        for (const memory of this.memories) {\n            const data = await memory.loadMemoryVariables(inputValues);\n            memoryData = {\n                ...memoryData,\n                ...data,\n            };\n        }\n        return memoryData;\n    }\n    /**\n     * Saves the context to all memory objects.\n     * @param inputValues Input values to save.\n     * @param outputValues Output values to save.\n     * @returns Promise that resolves when the context has been saved to all memory objects.\n     */\n    async saveContext(inputValues, outputValues) {\n        for (const memory of this.memories) {\n            await memory.saveContext(inputValues, outputValues);\n        }\n    }\n    /**\n     * Clears all memory objects.\n     * @returns Promise that resolves when all memory objects have been cleared.\n     */\n    async clear() {\n        for (const memory of this.memories) {\n            if (typeof memory.clear === \"function\") {\n                await memory.clear();\n            }\n        }\n    }\n    get memoryKeys() {\n        const memoryKeys = [];\n        for (const memory of this.memories) {\n            memoryKeys.push(...memory.memoryKeys);\n        }\n        return memoryKeys;\n    }\n}\n", "import { getBufferString } from \"@langchain/core/messages\";\nimport { BaseConversationSummaryMemory, } from \"./summary.js\";\n/**\n * Class that extends BaseConversationSummaryMemory and implements\n * ConversationSummaryBufferMemoryInput. It manages the conversation\n * history in a LangChain application by maintaining a buffer of chat\n * messages and providing methods to load, save, prune, and clear the\n * memory.\n * @example\n * ```typescript\n * // Initialize the memory with a specific model and token limit\n * const memory = new ConversationSummaryBufferMemory({\n *   llm: new ChatOpenAI({ modelName: \"gpt-3.5-turbo-instruct\", temperature: 0 }),\n *   maxTokenLimit: 10,\n * });\n *\n * // Save conversation context to memory\n * await memory.saveContext({ input: \"hi\" }, { output: \"whats up\" });\n * await memory.saveContext({ input: \"not much you\" }, { output: \"not much\" });\n *\n * // Load the conversation history from memory\n * const history = await memory.loadMemoryVariables({});\n * console.log({ history });\n *\n * // Create a chat prompt using the conversation history\n * const chatPrompt = ChatPromptTemplate.fromMessages([\n *   SystemMessagePromptTemplate.fromTemplate(\n *     \"The following is a friendly conversation between a human and an AI. The AI is talkative and provides lots of specific details from its context. If the AI does not know the answer to a question, it truthfully says it does not know.\",\n *   ),\n *   new MessagesPlaceholder(\"history\"),\n *   HumanMessagePromptTemplate.fromTemplate(\"{input}\"),\n * ]);\n *\n * // Initialize the conversation chain with the model, memory, and prompt\n * const chain = new ConversationChain({\n *   llm: new ChatOpenAI({ temperature: 0.9, verbose: true }),\n *   memory: memory,\n *   prompt: chatPrompt,\n * });\n * ```\n */\nexport class ConversationSummaryBufferMemory extends BaseConversationSummaryMemory {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"movingSummaryBuffer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"\"\n        });\n        Object.defineProperty(this, \"maxTokenLimit\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 2000\n        });\n        this.maxTokenLimit = fields?.maxTokenLimit ?? this.maxTokenLimit;\n    }\n    get memoryKeys() {\n        return [this.memoryKey];\n    }\n    /**\n     * Method that loads the chat messages from the memory and returns them as\n     * a string or as a list of messages, depending on the returnMessages\n     * property.\n     * @param _ InputValues object, not used in this method.\n     * @returns Promise that resolves with MemoryVariables object containing the loaded chat messages.\n     */\n    async loadMemoryVariables(_) {\n        let buffer = await this.chatHistory.getMessages();\n        if (this.movingSummaryBuffer) {\n            buffer = [\n                new this.summaryChatMessageClass(this.movingSummaryBuffer),\n                ...buffer,\n            ];\n        }\n        let finalBuffer;\n        if (this.returnMessages) {\n            finalBuffer = buffer;\n        }\n        else {\n            finalBuffer = getBufferString(buffer, this.humanPrefix, this.aiPrefix);\n        }\n        return { [this.memoryKey]: finalBuffer };\n    }\n    /**\n     * Method that saves the context of the conversation, including the input\n     * and output values, and prunes the memory if it exceeds the maximum\n     * token limit.\n     * @param inputValues InputValues object containing the input values of the conversation.\n     * @param outputValues OutputValues object containing the output values of the conversation.\n     * @returns Promise that resolves when the context is saved and the memory is pruned.\n     */\n    async saveContext(inputValues, outputValues) {\n        await super.saveContext(inputValues, outputValues);\n        await this.prune();\n    }\n    /**\n     * Method that prunes the memory if the total number of tokens in the\n     * buffer exceeds the maxTokenLimit. It removes messages from the\n     * beginning of the buffer until the total number of tokens is within the\n     * limit.\n     * @returns Promise that resolves when the memory is pruned.\n     */\n    async prune() {\n        // Prune buffer if it exceeds max token limit\n        let buffer = await this.chatHistory.getMessages();\n        if (this.movingSummaryBuffer) {\n            buffer = [\n                new this.summaryChatMessageClass(this.movingSummaryBuffer),\n                ...buffer,\n            ];\n        }\n        let currBufferLength = await this.llm.getNumTokens(getBufferString(buffer, this.humanPrefix, this.aiPrefix));\n        if (currBufferLength > this.maxTokenLimit) {\n            const prunedMemory = [];\n            while (currBufferLength > this.maxTokenLimit) {\n                const poppedMessage = buffer.shift();\n                if (poppedMessage) {\n                    prunedMemory.push(poppedMessage);\n                    currBufferLength = await this.llm.getNumTokens(getBufferString(buffer, this.humanPrefix, this.aiPrefix));\n                }\n            }\n            this.movingSummaryBuffer = await this.predictNewSummary(prunedMemory, this.movingSummaryBuffer);\n        }\n    }\n    /**\n     * Method that clears the memory and resets the movingSummaryBuffer.\n     * @returns Promise that resolves when the memory is cleared.\n     */\n    async clear() {\n        await super.clear();\n        this.movingSummaryBuffer = \"\";\n    }\n}\n", "import { BaseChatMemory, } from \"@langchain/community/memory/chat_memory\";\nimport { getBufferString } from \"@langchain/core/messages\";\n/**\n * Class that represents a conversation chat memory with a token buffer.\n * It extends the `BaseChatMemory` class and implements the\n * `ConversationTokenBufferMemoryInput` interface.\n * @example\n * ```typescript\n * const memory = new ConversationTokenBufferMemory({\n *   llm: new ChatOpenAI({}),\n *   maxTokenLimit: 10,\n * });\n *\n * // Save conversation context\n * await memory.saveContext({ input: \"hi\" }, { output: \"whats up\" });\n * await memory.saveContext({ input: \"not much you\" }, { output: \"not much\" });\n *\n * // Load memory variables\n * const result = await memory.loadMemoryVariables({});\n * console.log(result);\n * ```\n */\nexport class ConversationTokenBufferMemory extends BaseChatMemory {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"humanPrefix\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Human\"\n        });\n        Object.defineProperty(this, \"aiPrefix\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AI\"\n        });\n        Object.defineProperty(this, \"memoryKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"history\"\n        });\n        Object.defineProperty(this, \"maxTokenLimit\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 2000\n        }); // Default max token limit of 2000 which can be overridden\n        Object.defineProperty(this, \"llm\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.llm = fields.llm;\n        this.humanPrefix = fields?.humanPrefix ?? this.humanPrefix;\n        this.aiPrefix = fields?.aiPrefix ?? this.aiPrefix;\n        this.memoryKey = fields?.memoryKey ?? this.memoryKey;\n        this.maxTokenLimit = fields?.maxTokenLimit ?? this.maxTokenLimit;\n    }\n    get memoryKeys() {\n        return [this.memoryKey];\n    }\n    /**\n     * Loads the memory variables. It takes an `InputValues` object as a\n     * parameter and returns a `Promise` that resolves with a\n     * `MemoryVariables` object.\n     * @param _values `InputValues` object.\n     * @returns A `Promise` that resolves with a `MemoryVariables` object.\n     */\n    async loadMemoryVariables(_values) {\n        const messages = await this.chatHistory.getMessages();\n        if (this.returnMessages) {\n            const result = {\n                [this.memoryKey]: messages,\n            };\n            return result;\n        }\n        const result = {\n            [this.memoryKey]: getBufferString(messages, this.humanPrefix, this.aiPrefix),\n        };\n        return result;\n    }\n    /**\n     * Saves the context from this conversation to buffer. If the amount\n     * of tokens required to save the buffer exceeds MAX_TOKEN_LIMIT,\n     * prune it.\n     */\n    async saveContext(inputValues, outputValues) {\n        await super.saveContext(inputValues, outputValues);\n        // Prune buffer if it exceeds the max token limit set for this instance.\n        const buffer = await this.chatHistory.getMessages();\n        let currBufferLength = await this.llm.getNumTokens(getBufferString(buffer, this.humanPrefix, this.aiPrefix));\n        if (currBufferLength > this.maxTokenLimit) {\n            const prunedMemory = [];\n            while (currBufferLength > this.maxTokenLimit) {\n                prunedMemory.push(buffer.shift());\n                currBufferLength = await this.llm.getNumTokens(getBufferString(buffer, this.humanPrefix, this.aiPrefix));\n            }\n        }\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,IAAM,+BAA+B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsB9B,IAAM,iBAA+B,IAAI,eAAe;AAAA,EAC3D,gBAAgB,CAAC,WAAW,WAAW;AAAA,EACvC,UAAU;AACd,CAAC;AACM,IAAM,+CAA+C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBrD,IAAM;AAAA;AAAA,EAEC,IAAI,eAAe;AAAA,IAC7B,gBAAgB,CAAC,YAAY,WAAW,OAAO;AAAA,IAC/C,UAAU;AAAA,EACd,CAAC;AAAA;AACM,IAAM,sCAAsC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmC5C,IAAM,2BAAyC,IAAI,eAAe;AAAA,EACrE,gBAAgB,CAAC,WAAW,OAAO;AAAA,EACnC,UAAU;AACd,CAAC;AACM,IAAM,yCAAyC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkB/C,IAAM,8BAA4C,IAAI,eAAe;AAAA,EACxE,gBAAgB,CAAC,UAAU,WAAW,WAAW,OAAO;AAAA,EACxD,UAAU;AACd,CAAC;;;ACpGM,IAAM,gCAAN,cAA4C,eAAe;AAAA,EAC9D,YAAY,QAAQ;AAChB,UAAM,EAAE,gBAAgB,UAAU,WAAW,aAAa,aAAa,UAAU,KAAK,QAAQ,wBAAyB,IAAI;AAC3H,UAAM,EAAE,gBAAgB,UAAU,WAAW,YAAY,CAAC;AAC1D,WAAO,eAAe,MAAM,aAAa;AAAA,MACrC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,eAAe;AAAA,MACvC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,YAAY;AAAA,MACpC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,OAAO;AAAA,MAC/B,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,UAAU;AAAA,MAClC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,2BAA2B;AAAA,MACnD,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,SAAK,aAAY,iCAAQ,cAAa,KAAK;AAC3C,SAAK,cAAc,eAAe,KAAK;AACvC,SAAK,WAAW,YAAY,KAAK;AACjC,SAAK,MAAM;AACX,SAAK,SAAS,UAAU,KAAK;AAC7B,SAAK,0BACD,2BAA2B,KAAK;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,kBAAkB,UAAU,iBAAiB;AAC/C,UAAM,WAAW,gBAAgB,UAAU,KAAK,aAAa,KAAK,QAAQ;AAC1E,UAAM,QAAQ,IAAI,SAAS,EAAE,KAAK,KAAK,KAAK,QAAQ,KAAK,OAAO,CAAC;AACjE,WAAO,MAAM,MAAM,QAAQ;AAAA,MACvB,SAAS;AAAA,MACT,WAAW;AAAA,IACf,CAAC;AAAA,EACL;AACJ;AA8BO,IAAM,4BAAN,cAAwC,8BAA8B;AAAA,EACzE,YAAY,QAAQ;AAChB,UAAM,MAAM;AACZ,WAAO,eAAe,MAAM,UAAU;AAAA,MAClC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AAAA,EACL;AAAA,EACA,IAAI,aAAa;AACb,WAAO,CAAC,KAAK,SAAS;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,oBAAoB,GAAG;AACzB,QAAI,KAAK,gBAAgB;AACrB,YAAMA,UAAS;AAAA,QACX,CAAC,KAAK,SAAS,GAAG,CAAC,IAAI,KAAK,wBAAwB,KAAK,MAAM,CAAC;AAAA,MACpE;AACA,aAAOA;AAAA,IACX;AACA,UAAM,SAAS,EAAE,CAAC,KAAK,SAAS,GAAG,KAAK,OAAO;AAC/C,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,YAAY,aAAa,cAAc;AACzC,UAAM,MAAM,YAAY,aAAa,YAAY;AACjD,UAAM,WAAW,MAAM,KAAK,YAAY,YAAY;AACpD,SAAK,SAAS,MAAM,KAAK,kBAAkB,SAAS,MAAM,EAAE,GAAG,KAAK,MAAM;AAAA,EAC9E;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAQ;AACV,UAAM,MAAM,MAAM;AAClB,SAAK,SAAS;AAAA,EAClB;AACJ;;;ACrHO,IAAM,qBAAN,cAAiC,eAAe;AAAA,EACnD,YAAY,QAAQ;AAChB,UAAM;AAAA,MACF,iBAAgB,iCAAQ,mBAAkB;AAAA,MAC1C,aAAa,iCAAQ;AAAA,MACrB,UAAU,iCAAQ;AAAA,MAClB,WAAW,iCAAQ;AAAA,IACvB,CAAC;AACD,WAAO,eAAe,MAAM,eAAe;AAAA,MACvC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,YAAY;AAAA,MACpC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,aAAa;AAAA,MACrC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,KAAK;AAAA,MAC7B,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,SAAK,eAAc,iCAAQ,gBAAe,KAAK;AAC/C,SAAK,YAAW,iCAAQ,aAAY,KAAK;AACzC,SAAK,aAAY,iCAAQ,cAAa,KAAK;AAC3C,SAAK,KAAI,iCAAQ,MAAK,KAAK;AAAA,EAC/B;AAAA,EACA,IAAI,aAAa;AACb,WAAO,CAAC,KAAK,SAAS;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,oBAAoB,SAAS;AAC/B,UAAM,WAAW,MAAM,KAAK,YAAY,YAAY;AACpD,QAAI,KAAK,gBAAgB;AACrB,YAAMC,UAAS;AAAA,QACX,CAAC,KAAK,SAAS,GAAG,SAAS,MAAM,CAAC,KAAK,IAAI,CAAC;AAAA,MAChD;AACA,aAAOA;AAAA,IACX;AACA,UAAM,SAAS;AAAA,MACX,CAAC,KAAK,SAAS,GAAG,gBAAgB,SAAS,MAAM,CAAC,KAAK,IAAI,CAAC,GAAG,KAAK,aAAa,KAAK,QAAQ;AAAA,IAClG;AACA,WAAO;AAAA,EACX;AACJ;;;ACzFA,IAAM,cAAc;AAMb,IAAM,kBAAN,cAA8B,eAAe;AAAA,EAChD,YAAY,QAAQ;AAChB,UAAM,EAAE,WAAW,KAAK,WAAW,SAAS,gBAAgB,UAAU,WAAW,aAAa,QAAQ,UAAU,GAAG,KAAK,IAAI;AAC5H,UAAM,EAAE,gBAAgB,UAAU,WAAW,YAAY,CAAC;AAC1D,WAAO,eAAe,MAAM,OAAO;AAAA,MAC/B,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,WAAW;AAAA,MACnC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,aAAa;AAAA,MACrC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,aAAa;AAAA,MACrC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,WAAW;AAAA,MACnC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,UAAU;AAAA,MAClC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AAED,WAAO,eAAe,MAAM,UAAU;AAAA,MAClC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,YAAY;AAAA,MACpC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,SAAK,SAAS,IAAI,YAAY,IAAI;AAClC,SAAK,YAAY;AACjB,SAAK,MAAM,OAAO,KAAK;AACvB,SAAK,YAAY,aAAa,KAAK;AACnC,SAAK,UAAU,WAAW,KAAK;AAC/B,SAAK,SAAS;AACd,SAAK,WAAW;AAAA,EACpB;AAAA,EACA,IAAI,aAAa;AACb,WAAO,CAAC,KAAK,SAAS;AAAA,EAC1B;AAAA,EACA,cAAc;AACV,UAAM,YAAY,KAAK,QAAQ;AAC/B,UAAM,UAAU;AAAA,MACZ,gBAAgB;AAAA,IACpB;AACA,QAAI,aAAa,EAAE,KAAK,UAAU,KAAK,WAAW;AAC9C,YAAM,IAAI,MAAM,qGAAqG;AAAA,IACzH;AACA,QAAI,aAAa,KAAK,UAAU,KAAK,UAAU;AAC3C,cAAQ,iBAAiB,IAAI,KAAK;AAClC,cAAQ,mBAAmB,IAAI,KAAK;AAAA,IACxC;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,OAAO;AACT,UAAM,MAAM,MAAM,KAAK,OAAO,KAAK,OAAO,GAAG,KAAK,GAAG,aAAa,KAAK,SAAS,WAAW;AAAA,MACvF,QAAQ,KAAK,UAAU,YAAY,QAAQ,KAAK,OAAO,IAAI;AAAA,MAC3D,SAAS,KAAK,YAAY;AAAA,IAC9B,CAAC;AACD,UAAM,OAAO,MAAM,IAAI,KAAK;AAC5B,UAAM,QAAO,6BAAM,SAAQ;AAC3B,UAAM,EAAE,WAAW,CAAC,GAAG,UAAU,OAAO,IAAI;AAC5C,UAAM,QAAQ,IAAI,SAAS,QAAQ,EAAE,IAAI,OAAO,YAAY;AACxD,UAAI,QAAQ,SAAS,MAAM;AACvB,cAAM,KAAK,YAAY,iBAAiB,QAAQ,OAAO;AAAA,MAC3D,OACK;AACD,cAAM,KAAK,YAAY,eAAe,QAAQ,OAAO;AAAA,MACzD;AAAA,IACJ,CAAC,CAAC;AACF,QAAI,WAAW,YAAY,QAAQ;AAC/B,WAAK,UAAU;AAAA,IACnB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,oBAAoB,SAAS;AAC/B,UAAM,WAAW,MAAM,KAAK,YAAY,YAAY;AACpD,QAAI,KAAK,gBAAgB;AACrB,YAAMC,UAAS;AAAA,QACX,CAAC,KAAK,SAAS,GAAG;AAAA,MACtB;AACA,aAAOA;AAAA,IACX;AACA,UAAM,SAAS;AAAA,MACX,CAAC,KAAK,SAAS,GAAG,gBAAgB,QAAQ;AAAA,IAC9C;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,YAAY,aAAa,cAAc;AACzC,UAAM,QAAQ,cAAc,aAAa,KAAK,QAAQ;AACtD,UAAM,SAAS,eAAe,cAAc,KAAK,SAAS;AAC1D,UAAM,QAAQ,IAAI;AAAA,MACd,KAAK,OAAO,KAAK,OAAO,GAAG,KAAK,GAAG,aAAa,KAAK,SAAS,WAAW;AAAA,QACrE,QAAQ,KAAK,UAAU,YAAY,QAAQ,KAAK,OAAO,IAAI;AAAA,QAC3D,QAAQ;AAAA,QACR,MAAM,KAAK,UAAU;AAAA,UACjB,UAAU;AAAA,YACN,EAAE,MAAM,SAAS,SAAS,GAAG,KAAK,GAAG;AAAA,YACrC,EAAE,MAAM,MAAM,SAAS,GAAG,MAAM,GAAG;AAAA,UACvC;AAAA,QACJ,CAAC;AAAA,QACD,SAAS,KAAK,YAAY;AAAA,MAC9B,CAAC;AAAA,MACD,MAAM,YAAY,aAAa,YAAY;AAAA,IAC/C,CAAC;AAAA,EACL;AACJ;;;ACxJO,IAAM,0BAA0B,CAAC,cAAc,UAAU,IAAI,CAAC,QAAQ,IAAI,WAAW,EAAE,KAAK,MAAM;;;AC2BlG,IAAM,6BAAN,cAAyC,WAAW;AAAA,EACvD,YAAY,QAAQ;AAChB,UAAM;AACN,WAAO,eAAe,MAAM,wBAAwB;AAAA,MAChD,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,YAAY;AAAA,MACpC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,aAAa;AAAA,MACrC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,cAAc;AAAA,MACtC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,SAAK,uBAAuB,OAAO;AACnC,SAAK,WAAW,OAAO;AACvB,SAAK,YAAY,OAAO,aAAa;AACrC,SAAK,aAAa,OAAO,cAAc;AAAA,EAC3C;AAAA,EACA,IAAI,aAAa;AACb,WAAO,CAAC,KAAK,SAAS;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,oBAAoB,QAAQ;AAC9B,UAAM,QAAQ,cAAc,QAAQ,KAAK,QAAQ;AACjD,UAAM,UAAU,MAAM,KAAK,qBAAqB,qBAAqB,KAAK;AAC1E,WAAO;AAAA,MACH,CAAC,KAAK,SAAS,GAAG,KAAK,aACjB,UACA,wBAAwB,OAAO;AAAA,IACzC;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,YAAY,aAAa,cAAc;AACzC,UAAM,OAAO,OAAO,QAAQ,WAAW,EAClC,OAAO,CAAC,CAAC,CAAC,MAAM,MAAM,KAAK,SAAS,EACpC,OAAO,OAAO,QAAQ,YAAY,CAAC,EACnC,IAAI,CAAC,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,KAAK,CAAC,EAAE,EAC5B,KAAK,IAAI;AACd,UAAM,KAAK,qBAAqB,aAAa;AAAA,MACzC,IAAI,SAAS,EAAE,aAAa,KAAK,CAAC;AAAA,IACtC,CAAC;AAAA,EACL;AACJ;;;AClGO,IAAM,kBAAN,cAA8B,aAAa;AAClD;;;ACDO,IAAM,sBAAN,cAAkC,gBAAgB;AAAA,EACrD,cAAc;AACV,UAAM;AACN,WAAO,eAAe,MAAM,gBAAgB;AAAA,MACxC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO,CAAC,aAAa,UAAU,UAAU,WAAW;AAAA,IACxD,CAAC;AACD,WAAO,eAAe,MAAM,SAAS;AAAA,MACjC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,SAAK,QAAQ,uBAAO,OAAO,IAAI;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,IAAI,KAAK,cAAc;AACzB,WAAO,OAAO,KAAK,QAAQ,KAAK,MAAM,GAAG,IAAI;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,IAAI,KAAK,OAAO;AAClB,SAAK,MAAM,GAAG,IAAI;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,OAAO,KAAK;AACd,WAAO,KAAK,MAAM,GAAG;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,OAAO,KAAK;AACd,WAAO,OAAO,KAAK;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,QAAQ;AACV,SAAK,QAAQ,uBAAO,OAAO,IAAI;AAAA,EACnC;AACJ;;;ACrBO,IAAM,eAAN,cAA2B,eAAe;AAAA,EAC7C,YAAY,QAAQ;AAChB,UAAM;AAAA,MACF,aAAa,OAAO;AAAA,MACpB,gBAAgB,OAAO,kBAAkB;AAAA,MACzC,UAAU,OAAO;AAAA,MACjB,WAAW,OAAO;AAAA,IACtB,CAAC;AACD,WAAO,eAAe,MAAM,yBAAyB;AAAA,MACjD,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,4BAA4B;AAAA,MACpD,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,eAAe;AAAA,MACvC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,eAAe;AAAA,MACvC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO,CAAC;AAAA,IACZ,CAAC;AACD,WAAO,eAAe,MAAM,KAAK;AAAA,MAC7B,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,kBAAkB;AAAA,MAC1C,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,OAAO;AAAA,MAC/B,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,eAAe;AAAA,MACvC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,eAAe;AAAA,MACvC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,YAAY;AAAA,MACpC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,SAAK,MAAM,OAAO;AAClB,SAAK,cAAc,OAAO;AAC1B,SAAK,WAAW,OAAO;AACvB,SAAK,iBAAiB,OAAO,kBAAkB,KAAK;AACpD,SAAK,cAAc,OAAO,eAAe,KAAK;AAC9C,SAAK,wBAAwB,IAAI,SAAS;AAAA,MACtC,KAAK,KAAK;AAAA,MACV,QAAQ,OAAO,0BAA0B;AAAA,IAC7C,CAAC;AACD,SAAK,2BAA2B,IAAI,SAAS;AAAA,MACzC,KAAK,KAAK;AAAA,MACV,QAAQ,OAAO,6BAA6B;AAAA,IAChD,CAAC;AACD,SAAK,cAAc,OAAO,eAAe,IAAI,oBAAoB;AACjE,SAAK,cAAc,OAAO,eAAe,KAAK;AAC9C,SAAK,IAAI,OAAO,KAAK,KAAK;AAAA,EAC9B;AAAA,EACA,IAAI,aAAa;AACb,WAAO,CAAC,KAAK,cAAc;AAAA,EAC/B;AAAA;AAAA,EAEA,IAAI,kBAAkB;AAClB,WAAO,CAAC,KAAK,aAAa,KAAK,cAAc;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,oBAAoB,QAAQ;AAC9B,UAAM,iBAAiB,KAAK,YAAY,kBAAkB,QAAQ,KAAK,eAAe;AACtF,UAAM,WAAW,MAAM,KAAK,YAAY,YAAY;AACpD,UAAM,qBAAqB,gBAAgB,SAAS,MAAM,CAAC,KAAK,IAAI,CAAC,GAAG,KAAK,aAAa,KAAK,QAAQ;AACvG,UAAM,SAAS,MAAM,KAAK,sBAAsB,QAAQ;AAAA,MACpD,SAAS;AAAA,MACT,OAAO,OAAO,cAAc;AAAA,IAChC,CAAC;AACD,UAAM,WAAW,OAAO,KAAK,MAAM,SAAS,CAAC,IAAI,OAAO,MAAM,GAAG,EAAE,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC;AACtF,UAAM,kBAAkB,CAAC;AACzB,eAAW,UAAU,UAAU;AAC3B,sBAAgB,MAAM,IAAI,MAAM,KAAK,YAAY,IAAI,QAAQ,+BAA+B;AAAA,IAChG;AACA,SAAK,cAAc,CAAC,GAAG,QAAQ;AAC/B,UAAM,SAAS,KAAK,iBACd,SAAS,MAAM,CAAC,KAAK,IAAI,CAAC,IAC1B;AACN,WAAO;AAAA,MACH,CAAC,KAAK,cAAc,GAAG;AAAA,MACvB,CAAC,KAAK,WAAW,GAAG;AAAA,IACxB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,YAAY,QAAQ,SAAS;AAC/B,UAAM,MAAM,YAAY,QAAQ,OAAO;AACvC,UAAM,iBAAiB,KAAK,YAAY,kBAAkB,QAAQ,KAAK,eAAe;AACtF,UAAM,WAAW,MAAM,KAAK,YAAY,YAAY;AACpD,UAAM,qBAAqB,gBAAgB,SAAS,MAAM,CAAC,KAAK,IAAI,CAAC,GAAG,KAAK,aAAa,KAAK,QAAQ;AACvG,UAAM,YAAY,OAAO,cAAc;AACvC,eAAW,UAAU,KAAK,aAAa;AACnC,YAAM,kBAAkB,MAAM,KAAK,YAAY,IAAI,QAAQ,+BAA+B;AAC1F,YAAM,SAAS,MAAM,KAAK,yBAAyB,QAAQ;AAAA,QACvD,SAAS;AAAA,QACT;AAAA,QACA,SAAS;AAAA,QACT,OAAO;AAAA,MACX,CAAC;AACD,UAAI,OAAO,KAAK,MAAM,aAAa;AAC/B,cAAM,KAAK,YAAY,IAAI,QAAQ,OAAO,KAAK,CAAC;AAAA,MACpD;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,QAAQ;AACV,UAAM,MAAM,MAAM;AAClB,UAAM,KAAK,YAAY,MAAM;AAAA,EACjC;AACJ;;;AC/LO,IAAM,iBAAN,cAA6B,eAAe;AAAA,EAC/C,YAAY,QAAQ;AAChB,UAAM;AAAA,MACF,aAAa,iCAAQ;AAAA,MACrB,iBAAgB,iCAAQ,mBAAkB;AAAA,MAC1C,UAAU,iCAAQ;AAAA,MAClB,WAAW,iCAAQ;AAAA,IACvB,CAAC;AACD,WAAO,eAAe,MAAM,eAAe;AAAA,MACvC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,YAAY;AAAA,MACpC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,aAAa;AAAA,MACrC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,YAAY;AAAA,MACpC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO,CAAC;AAAA,IACZ,CAAC;AACD,SAAK,YAAW,iCAAQ,aAAY,KAAK;AACzC,SAAK,eAAc,iCAAQ,gBAAe,KAAK;AAC/C,SAAK,YAAW,iCAAQ,aAAY,KAAK;AACzC,SAAK,aAAY,iCAAQ,cAAa,KAAK;AAC3C,SAAK,4BAA4B;AACjC,SAAK,cAAc;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,8BAA8B;AAC1B,UAAM,eAAe,CAAC;AACtB,eAAW,UAAU,KAAK,UAAU;AAChC,YAAM,UAAU,aAAa,OAAO,CAAC,MAAM,OAAO,WAAW,SAAS,CAAC,CAAC;AACxE,UAAI,QAAQ,SAAS,GAAG;AACpB,cAAM,IAAI,MAAM,sBAAsB;AAAA,UAClC,GAAG;AAAA,QACP,CAAC,gFAAgF;AAAA,MACrF;AACA,mBAAa,KAAK,GAAG,OAAO,UAAU;AAAA,IAC1C;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAgB;AACZ,eAAW,UAAU,KAAK,UAAU;AAChC,UAAI,OAAO,gBAAgB,UACvB,OAAO,aAAa,QAAW;AAC/B,gBAAQ,KAAK,6FAA6F,MAAM,GAAG;AAAA,MACvH;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,oBAAoB,aAAa;AACnC,QAAI,aAAa,CAAC;AAClB,eAAW,UAAU,KAAK,UAAU;AAChC,YAAM,OAAO,MAAM,OAAO,oBAAoB,WAAW;AACzD,mBAAa;AAAA,QACT,GAAG;AAAA,QACH,GAAG;AAAA,MACP;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,YAAY,aAAa,cAAc;AACzC,eAAW,UAAU,KAAK,UAAU;AAChC,YAAM,OAAO,YAAY,aAAa,YAAY;AAAA,IACtD;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAQ;AACV,eAAW,UAAU,KAAK,UAAU;AAChC,UAAI,OAAO,OAAO,UAAU,YAAY;AACpC,cAAM,OAAO,MAAM;AAAA,MACvB;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,IAAI,aAAa;AACb,UAAM,aAAa,CAAC;AACpB,eAAW,UAAU,KAAK,UAAU;AAChC,iBAAW,KAAK,GAAG,OAAO,UAAU;AAAA,IACxC;AACA,WAAO;AAAA,EACX;AACJ;;;AC7EO,IAAM,kCAAN,cAA8C,8BAA8B;AAAA,EAC/E,YAAY,QAAQ;AAChB,UAAM,MAAM;AACZ,WAAO,eAAe,MAAM,uBAAuB;AAAA,MAC/C,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,iBAAiB;AAAA,MACzC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,SAAK,iBAAgB,iCAAQ,kBAAiB,KAAK;AAAA,EACvD;AAAA,EACA,IAAI,aAAa;AACb,WAAO,CAAC,KAAK,SAAS;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,oBAAoB,GAAG;AACzB,QAAI,SAAS,MAAM,KAAK,YAAY,YAAY;AAChD,QAAI,KAAK,qBAAqB;AAC1B,eAAS;AAAA,QACL,IAAI,KAAK,wBAAwB,KAAK,mBAAmB;AAAA,QACzD,GAAG;AAAA,MACP;AAAA,IACJ;AACA,QAAI;AACJ,QAAI,KAAK,gBAAgB;AACrB,oBAAc;AAAA,IAClB,OACK;AACD,oBAAc,gBAAgB,QAAQ,KAAK,aAAa,KAAK,QAAQ;AAAA,IACzE;AACA,WAAO,EAAE,CAAC,KAAK,SAAS,GAAG,YAAY;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,YAAY,aAAa,cAAc;AACzC,UAAM,MAAM,YAAY,aAAa,YAAY;AACjD,UAAM,KAAK,MAAM;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,QAAQ;AAEV,QAAI,SAAS,MAAM,KAAK,YAAY,YAAY;AAChD,QAAI,KAAK,qBAAqB;AAC1B,eAAS;AAAA,QACL,IAAI,KAAK,wBAAwB,KAAK,mBAAmB;AAAA,QACzD,GAAG;AAAA,MACP;AAAA,IACJ;AACA,QAAI,mBAAmB,MAAM,KAAK,IAAI,aAAa,gBAAgB,QAAQ,KAAK,aAAa,KAAK,QAAQ,CAAC;AAC3G,QAAI,mBAAmB,KAAK,eAAe;AACvC,YAAM,eAAe,CAAC;AACtB,aAAO,mBAAmB,KAAK,eAAe;AAC1C,cAAM,gBAAgB,OAAO,MAAM;AACnC,YAAI,eAAe;AACf,uBAAa,KAAK,aAAa;AAC/B,6BAAmB,MAAM,KAAK,IAAI,aAAa,gBAAgB,QAAQ,KAAK,aAAa,KAAK,QAAQ,CAAC;AAAA,QAC3G;AAAA,MACJ;AACA,WAAK,sBAAsB,MAAM,KAAK,kBAAkB,cAAc,KAAK,mBAAmB;AAAA,IAClG;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAQ;AACV,UAAM,MAAM,MAAM;AAClB,SAAK,sBAAsB;AAAA,EAC/B;AACJ;;;AChHO,IAAM,gCAAN,cAA4C,eAAe;AAAA,EAC9D,YAAY,QAAQ;AAChB,UAAM,MAAM;AACZ,WAAO,eAAe,MAAM,eAAe;AAAA,MACvC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,YAAY;AAAA,MACpC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,aAAa;AAAA,MACrC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,iBAAiB;AAAA,MACzC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,OAAO;AAAA,MAC/B,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,SAAK,MAAM,OAAO;AAClB,SAAK,eAAc,iCAAQ,gBAAe,KAAK;AAC/C,SAAK,YAAW,iCAAQ,aAAY,KAAK;AACzC,SAAK,aAAY,iCAAQ,cAAa,KAAK;AAC3C,SAAK,iBAAgB,iCAAQ,kBAAiB,KAAK;AAAA,EACvD;AAAA,EACA,IAAI,aAAa;AACb,WAAO,CAAC,KAAK,SAAS;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,oBAAoB,SAAS;AAC/B,UAAM,WAAW,MAAM,KAAK,YAAY,YAAY;AACpD,QAAI,KAAK,gBAAgB;AACrB,YAAMC,UAAS;AAAA,QACX,CAAC,KAAK,SAAS,GAAG;AAAA,MACtB;AACA,aAAOA;AAAA,IACX;AACA,UAAM,SAAS;AAAA,MACX,CAAC,KAAK,SAAS,GAAG,gBAAgB,UAAU,KAAK,aAAa,KAAK,QAAQ;AAAA,IAC/E;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,YAAY,aAAa,cAAc;AACzC,UAAM,MAAM,YAAY,aAAa,YAAY;AAEjD,UAAM,SAAS,MAAM,KAAK,YAAY,YAAY;AAClD,QAAI,mBAAmB,MAAM,KAAK,IAAI,aAAa,gBAAgB,QAAQ,KAAK,aAAa,KAAK,QAAQ,CAAC;AAC3G,QAAI,mBAAmB,KAAK,eAAe;AACvC,YAAM,eAAe,CAAC;AACtB,aAAO,mBAAmB,KAAK,eAAe;AAC1C,qBAAa,KAAK,OAAO,MAAM,CAAC;AAChC,2BAAmB,MAAM,KAAK,IAAI,aAAa,gBAAgB,QAAQ,KAAK,aAAa,KAAK,QAAQ,CAAC;AAAA,MAC3G;AAAA,IACJ;AAAA,EACJ;AACJ;",
  "names": ["result", "result", "result", "result"]
}
