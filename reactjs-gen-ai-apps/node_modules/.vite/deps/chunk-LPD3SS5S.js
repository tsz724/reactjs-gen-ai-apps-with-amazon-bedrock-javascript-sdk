import {
  BaseLangChain,
  RUN_KEY
} from "./chunk-QVZUGSRS.js";
import {
  CallbackManager,
  parseCallbackConfigArg
} from "./chunk-Y4Y4AWYL.js";

// node_modules/langchain/dist/chains/base.js
var BaseChain = class extends BaseLangChain {
  get lc_namespace() {
    return ["langchain", "chains", this._chainType()];
  }
  constructor(fields, verbose, callbacks) {
    if (arguments.length === 1 && typeof fields === "object" && !("saveContext" in fields)) {
      const { memory, callbackManager, ...rest } = fields;
      super({ ...rest, callbacks: callbackManager ?? rest.callbacks });
      this.memory = memory;
    } else {
      super({ verbose, callbacks });
      this.memory = fields;
    }
  }
  /** @ignore */
  _selectMemoryInputs(values) {
    const valuesForMemory = { ...values };
    if ("signal" in valuesForMemory) {
      delete valuesForMemory.signal;
    }
    if ("timeout" in valuesForMemory) {
      delete valuesForMemory.timeout;
    }
    return valuesForMemory;
  }
  /**
   * Invoke the chain with the provided input and returns the output.
   * @param input Input values for the chain run.
   * @param config Optional configuration for the Runnable.
   * @returns Promise that resolves with the output of the chain run.
   */
  async invoke(input, config) {
    const fullValues = await this._formatValues(input);
    const callbackManager_ = await CallbackManager.configure(config == null ? void 0 : config.callbacks, this.callbacks, config == null ? void 0 : config.tags, this.tags, config == null ? void 0 : config.metadata, this.metadata, { verbose: this.verbose });
    const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), fullValues, void 0, void 0, void 0, void 0, config == null ? void 0 : config.runName));
    let outputValues;
    try {
      outputValues = await (fullValues.signal ? Promise.race([
        this._call(fullValues, runManager),
        new Promise((_, reject) => {
          var _a;
          (_a = fullValues.signal) == null ? void 0 : _a.addEventListener("abort", () => {
            reject(new Error("AbortError"));
          });
        })
      ]) : this._call(fullValues, runManager));
    } catch (e) {
      await (runManager == null ? void 0 : runManager.handleChainError(e));
      throw e;
    }
    if (!(this.memory == null)) {
      await this.memory.saveContext(this._selectMemoryInputs(input), outputValues);
    }
    await (runManager == null ? void 0 : runManager.handleChainEnd(outputValues));
    Object.defineProperty(outputValues, RUN_KEY, {
      value: runManager ? { runId: runManager == null ? void 0 : runManager.runId } : void 0,
      configurable: true
    });
    return outputValues;
  }
  _validateOutputs(outputs) {
    const missingKeys = this.outputKeys.filter((k) => !(k in outputs));
    if (missingKeys.length) {
      throw new Error(`Missing output keys: ${missingKeys.join(", ")} from chain ${this._chainType()}`);
    }
  }
  async prepOutputs(inputs, outputs, returnOnlyOutputs = false) {
    this._validateOutputs(outputs);
    if (this.memory) {
      await this.memory.saveContext(inputs, outputs);
    }
    if (returnOnlyOutputs) {
      return outputs;
    }
    return { ...inputs, ...outputs };
  }
  /**
   * Return a json-like object representing this chain.
   */
  serialize() {
    throw new Error("Method not implemented.");
  }
  /** @deprecated Use .invoke() instead. Will be removed in 0.2.0. */
  async run(input, config) {
    const inputKeys = this.inputKeys.filter((k) => {
      var _a;
      return !((_a = this.memory) == null ? void 0 : _a.memoryKeys.includes(k));
    });
    const isKeylessInput = inputKeys.length <= 1;
    if (!isKeylessInput) {
      throw new Error(`Chain ${this._chainType()} expects multiple inputs, cannot use 'run' `);
    }
    const values = inputKeys.length ? { [inputKeys[0]]: input } : {};
    const returnValues = await this.call(values, config);
    const keys = Object.keys(returnValues);
    if (keys.length === 1) {
      return returnValues[keys[0]];
    }
    throw new Error("return values have multiple keys, `run` only supported when one key currently");
  }
  async _formatValues(values) {
    const fullValues = { ...values };
    if (fullValues.timeout && !fullValues.signal) {
      fullValues.signal = AbortSignal.timeout(fullValues.timeout);
      delete fullValues.timeout;
    }
    if (!(this.memory == null)) {
      const newValues = await this.memory.loadMemoryVariables(this._selectMemoryInputs(values));
      for (const [key, value] of Object.entries(newValues)) {
        fullValues[key] = value;
      }
    }
    return fullValues;
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
   *
   * Run the core logic of this chain and add to output if desired.
   *
   * Wraps _call and handles memory.
   */
  async call(values, config, tags) {
    const parsedConfig = { tags, ...parseCallbackConfigArg(config) };
    return this.invoke(values, parsedConfig);
  }
  /**
   * @deprecated Use .batch() instead. Will be removed in 0.2.0.
   *
   * Call the chain on all inputs in the list
   */
  async apply(inputs, config) {
    return Promise.all(inputs.map(async (i, idx) => this.call(i, config == null ? void 0 : config[idx])));
  }
  /**
   * Load a chain from a json-like object describing it.
   */
  static async deserialize(data, values = {}) {
    switch (data._type) {
      case "llm_chain": {
        const { LLMChain } = await import("./llm_chain-YMNTDHHT.js");
        return LLMChain.deserialize(data);
      }
      case "sequential_chain": {
        const { SequentialChain } = await import("./sequential_chain-47ZAPKBP.js");
        return SequentialChain.deserialize(data);
      }
      case "simple_sequential_chain": {
        const { SimpleSequentialChain } = await import("./sequential_chain-47ZAPKBP.js");
        return SimpleSequentialChain.deserialize(data);
      }
      case "stuff_documents_chain": {
        const { StuffDocumentsChain } = await import("./combine_docs_chain-CDJ464D4.js");
        return StuffDocumentsChain.deserialize(data);
      }
      case "map_reduce_documents_chain": {
        const { MapReduceDocumentsChain } = await import("./combine_docs_chain-CDJ464D4.js");
        return MapReduceDocumentsChain.deserialize(data);
      }
      case "refine_documents_chain": {
        const { RefineDocumentsChain } = await import("./combine_docs_chain-CDJ464D4.js");
        return RefineDocumentsChain.deserialize(data);
      }
      case "vector_db_qa": {
        const { VectorDBQAChain } = await import("./vector_db_qa-QV55BZPJ.js");
        return VectorDBQAChain.deserialize(data, values);
      }
      case "api_chain": {
        const { APIChain } = await import("./api_chain-B3OTBWOC.js");
        return APIChain.deserialize(data);
      }
      default:
        throw new Error(`Invalid prompt type in config: ${data._type}`);
    }
  }
};

export {
  BaseChain
};
//# sourceMappingURL=chunk-LPD3SS5S.js.map
