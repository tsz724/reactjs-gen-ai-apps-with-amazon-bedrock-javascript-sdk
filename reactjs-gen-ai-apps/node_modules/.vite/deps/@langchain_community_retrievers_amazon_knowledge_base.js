import {
  CallbackManager,
  Runnable,
  ensureConfig,
  parseCallbackConfigArg
} from "./chunk-Y4Y4AWYL.js";
import {
  BedrockAgentRuntimeClient,
  RetrieveCommand
} from "./chunk-EHJOIZAX.js";
import "./chunk-M323MHFS.js";
import "./chunk-MSF4XV6C.js";
import "./chunk-KD35WQG2.js";
import "./chunk-HSLQ6YIW.js";
import "./chunk-WXXH56N5.js";

// node_modules/@langchain/core/dist/retrievers.js
var BaseRetriever = class extends Runnable {
  constructor(fields) {
    super(fields);
    Object.defineProperty(this, "callbacks", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "tags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "metadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "verbose", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.callbacks = fields == null ? void 0 : fields.callbacks;
    this.tags = (fields == null ? void 0 : fields.tags) ?? [];
    this.metadata = (fields == null ? void 0 : fields.metadata) ?? {};
    this.verbose = (fields == null ? void 0 : fields.verbose) ?? false;
  }
  /**
   * TODO: This should be an abstract method, but we'd like to avoid breaking
   * changes to people currently using subclassed custom retrievers.
   * Change it on next major release.
   */
  _getRelevantDocuments(_query, _callbacks) {
    throw new Error("Not implemented!");
  }
  async invoke(input, options) {
    return this.getRelevantDocuments(input, options);
  }
  /**
   * Main method used to retrieve relevant documents. It takes a query
   * string and an optional configuration object, and returns a promise that
   * resolves to an array of `Document` objects. This method handles the
   * retrieval process, including starting and ending callbacks, and error
   * handling.
   * @param query The query string to retrieve relevant documents for.
   * @param config Optional configuration object for the retrieval process.
   * @returns A promise that resolves to an array of `Document` objects.
   */
  async getRelevantDocuments(query, config) {
    const parsedConfig = ensureConfig(parseCallbackConfigArg(config));
    const callbackManager_ = await CallbackManager.configure(parsedConfig.callbacks, this.callbacks, parsedConfig.tags, this.tags, parsedConfig.metadata, this.metadata, { verbose: this.verbose });
    const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleRetrieverStart(this.toJSON(), query, void 0, void 0, void 0, void 0, parsedConfig.runName));
    try {
      const results = await this._getRelevantDocuments(query, runManager);
      await (runManager == null ? void 0 : runManager.handleRetrieverEnd(results));
      return results;
    } catch (error) {
      await (runManager == null ? void 0 : runManager.handleRetrieverError(error));
      throw error;
    }
  }
};

// node_modules/@langchain/community/dist/retrievers/amazon_knowledge_base.js
var AmazonKnowledgeBaseRetriever = class extends BaseRetriever {
  static lc_name() {
    return "AmazonKnowledgeBaseRetriever";
  }
  constructor({ knowledgeBaseId, topK = 10, clientOptions, region }) {
    super();
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain", "retrievers", "amazon_bedrock_knowledge_base"]
    });
    Object.defineProperty(this, "knowledgeBaseId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "topK", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "bedrockAgentRuntimeClient", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.topK = topK;
    this.bedrockAgentRuntimeClient = new BedrockAgentRuntimeClient({
      region,
      ...clientOptions
    });
    this.knowledgeBaseId = knowledgeBaseId;
  }
  /**
   * Cleans the result text by replacing sequences of whitespace with a
   * single space and removing ellipses.
   * @param resText The result text to clean.
   * @returns The cleaned result text.
   */
  cleanResult(resText) {
    const res = resText.replace(/\s+/g, " ").replace(/\.\.\./g, "");
    return res;
  }
  async queryKnowledgeBase(query, topK) {
    var _a;
    const retrieveCommand = new RetrieveCommand({
      knowledgeBaseId: this.knowledgeBaseId,
      retrievalQuery: {
        text: query
      },
      retrievalConfiguration: {
        vectorSearchConfiguration: {
          numberOfResults: topK
        }
      }
    });
    const retrieveResponse = await this.bedrockAgentRuntimeClient.send(retrieveCommand);
    return ((_a = retrieveResponse.retrievalResults) == null ? void 0 : _a.map((result) => {
      var _a2, _b, _c;
      return {
        pageContent: this.cleanResult(((_a2 = result.content) == null ? void 0 : _a2.text) || ""),
        metadata: {
          source: (_c = (_b = result.location) == null ? void 0 : _b.s3Location) == null ? void 0 : _c.uri,
          score: result.score
        }
      };
    })) ?? [];
  }
  async _getRelevantDocuments(query) {
    const docs = await this.queryKnowledgeBase(query, this.topK);
    return docs;
  }
};
export {
  AmazonKnowledgeBaseRetriever
};
//# sourceMappingURL=@langchain_community_retrievers_amazon_knowledge_base.js.map
