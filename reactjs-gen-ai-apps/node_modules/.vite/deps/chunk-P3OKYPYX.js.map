{
  "version": 3,
  "sources": ["../../@langchain/core/dist/language_models/llms.js"],
  "sourcesContent": ["import { AIMessage, getBufferString, } from \"../messages/index.js\";\nimport { RUN_KEY, GenerationChunk, } from \"../outputs.js\";\nimport { CallbackManager, } from \"../callbacks/manager.js\";\nimport { BaseLanguageModel, } from \"./base.js\";\n/**\n * LLM Wrapper. Takes in a prompt (or prompts) and returns a string.\n */\nexport class BaseLLM extends BaseLanguageModel {\n    constructor({ concurrency, ...rest }) {\n        super(concurrency ? { maxConcurrency: concurrency, ...rest } : rest);\n        // Only ever instantiated in main LangChain\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"llms\", this._llmType()]\n        });\n    }\n    /**\n     * This method takes an input and options, and returns a string. It\n     * converts the input to a prompt value and generates a result based on\n     * the prompt.\n     * @param input Input for the LLM.\n     * @param options Options for the LLM call.\n     * @returns A string result based on the prompt.\n     */\n    async invoke(input, options) {\n        const promptValue = BaseLLM._convertInputToPromptValue(input);\n        const result = await this.generatePrompt([promptValue], options, options?.callbacks);\n        return result.generations[0][0].text;\n    }\n    // eslint-disable-next-line require-yield\n    async *_streamResponseChunks(_input, _options, _runManager) {\n        throw new Error(\"Not implemented.\");\n    }\n    _separateRunnableConfigFromCallOptions(options) {\n        const [runnableConfig, callOptions] = super._separateRunnableConfigFromCallOptions(options);\n        if (callOptions?.timeout && !callOptions.signal) {\n            callOptions.signal = AbortSignal.timeout(callOptions.timeout);\n        }\n        return [runnableConfig, callOptions];\n    }\n    async *_streamIterator(input, options) {\n        // Subclass check required to avoid double callbacks with default implementation\n        if (this._streamResponseChunks === BaseLLM.prototype._streamResponseChunks) {\n            yield this.invoke(input, options);\n        }\n        else {\n            const prompt = BaseLLM._convertInputToPromptValue(input);\n            const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptions(options);\n            const callbackManager_ = await CallbackManager.configure(runnableConfig.callbacks, this.callbacks, runnableConfig.tags, this.tags, runnableConfig.metadata, this.metadata, { verbose: this.verbose });\n            const extra = {\n                options: callOptions,\n                invocation_params: this?.invocationParams(callOptions),\n                batch_size: 1,\n            };\n            const runManagers = await callbackManager_?.handleLLMStart(this.toJSON(), [prompt.toString()], undefined, undefined, extra, undefined, undefined, runnableConfig.runName);\n            let generation = new GenerationChunk({\n                text: \"\",\n            });\n            try {\n                for await (const chunk of this._streamResponseChunks(input.toString(), callOptions, runManagers?.[0])) {\n                    if (!generation) {\n                        generation = chunk;\n                    }\n                    else {\n                        generation = generation.concat(chunk);\n                    }\n                    if (typeof chunk.text === \"string\") {\n                        yield chunk.text;\n                    }\n                }\n            }\n            catch (err) {\n                await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMError(err)));\n                throw err;\n            }\n            await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMEnd({\n                generations: [[generation]],\n            })));\n        }\n    }\n    /**\n     * This method takes prompt values, options, and callbacks, and generates\n     * a result based on the prompts.\n     * @param promptValues Prompt values for the LLM.\n     * @param options Options for the LLM call.\n     * @param callbacks Callbacks for the LLM call.\n     * @returns An LLMResult based on the prompts.\n     */\n    async generatePrompt(promptValues, options, callbacks) {\n        const prompts = promptValues.map((promptValue) => promptValue.toString());\n        return this.generate(prompts, options, callbacks);\n    }\n    /**\n     * Get the parameters used to invoke the model\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    invocationParams(_options) {\n        return {};\n    }\n    _flattenLLMResult(llmResult) {\n        const llmResults = [];\n        for (let i = 0; i < llmResult.generations.length; i += 1) {\n            const genList = llmResult.generations[i];\n            if (i === 0) {\n                llmResults.push({\n                    generations: [genList],\n                    llmOutput: llmResult.llmOutput,\n                });\n            }\n            else {\n                const llmOutput = llmResult.llmOutput\n                    ? { ...llmResult.llmOutput, tokenUsage: {} }\n                    : undefined;\n                llmResults.push({\n                    generations: [genList],\n                    llmOutput,\n                });\n            }\n        }\n        return llmResults;\n    }\n    /** @ignore */\n    async _generateUncached(prompts, parsedOptions, handledOptions) {\n        const callbackManager_ = await CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, handledOptions.metadata, this.metadata, { verbose: this.verbose });\n        const extra = {\n            options: parsedOptions,\n            invocation_params: this?.invocationParams(parsedOptions),\n            batch_size: prompts.length,\n        };\n        const runManagers = await callbackManager_?.handleLLMStart(this.toJSON(), prompts, undefined, undefined, extra, undefined, undefined, handledOptions?.runName);\n        let output;\n        try {\n            output = await this._generate(prompts, parsedOptions, runManagers?.[0]);\n        }\n        catch (err) {\n            await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMError(err)));\n            throw err;\n        }\n        const flattenedOutputs = this._flattenLLMResult(output);\n        await Promise.all((runManagers ?? []).map((runManager, i) => runManager?.handleLLMEnd(flattenedOutputs[i])));\n        const runIds = runManagers?.map((manager) => manager.runId) || undefined;\n        // This defines RUN_KEY as a non-enumerable property on the output object\n        // so that it is not serialized when the output is stringified, and so that\n        // it isnt included when listing the keys of the output object.\n        Object.defineProperty(output, RUN_KEY, {\n            value: runIds ? { runIds } : undefined,\n            configurable: true,\n        });\n        return output;\n    }\n    async _generateCached({ prompts, cache, llmStringKey, parsedOptions, handledOptions, }) {\n        const callbackManager_ = await CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, handledOptions.metadata, this.metadata, { verbose: this.verbose });\n        const extra = {\n            options: parsedOptions,\n            invocation_params: this?.invocationParams(parsedOptions),\n            batch_size: prompts.length,\n            cached: true,\n        };\n        const runManagers = await callbackManager_?.handleLLMStart(this.toJSON(), prompts, undefined, undefined, extra, undefined, undefined, handledOptions?.runName);\n        // generate results\n        const missingPromptIndices = [];\n        const results = await Promise.allSettled(prompts.map(async (prompt, index) => {\n            const result = await cache.lookup(prompt, llmStringKey);\n            if (result == null) {\n                missingPromptIndices.push(index);\n            }\n            return result;\n        }));\n        // Map run managers to the results before filtering out null results\n        // Null results are just absent from the cache.\n        const cachedResults = results\n            .map((result, index) => ({ result, runManager: runManagers?.[index] }))\n            .filter(({ result }) => (result.status === \"fulfilled\" && result.value != null) ||\n            result.status === \"rejected\");\n        // Handle results and call run managers\n        const generations = [];\n        await Promise.all(cachedResults.map(async ({ result: promiseResult, runManager }, i) => {\n            if (promiseResult.status === \"fulfilled\") {\n                const result = promiseResult.value;\n                generations[i] = result;\n                if (result.length) {\n                    await runManager?.handleLLMNewToken(result[0].text);\n                }\n                return runManager?.handleLLMEnd({\n                    generations: [result],\n                });\n            }\n            else {\n                // status === \"rejected\"\n                await runManager?.handleLLMError(promiseResult.reason);\n                return Promise.reject(promiseResult.reason);\n            }\n        }));\n        const output = {\n            generations,\n            missingPromptIndices,\n        };\n        // This defines RUN_KEY as a non-enumerable property on the output object\n        // so that it is not serialized when the output is stringified, and so that\n        // it isnt included when listing the keys of the output object.\n        Object.defineProperty(output, RUN_KEY, {\n            value: runManagers\n                ? { runIds: runManagers?.map((manager) => manager.runId) }\n                : undefined,\n            configurable: true,\n        });\n        return output;\n    }\n    /**\n     * Run the LLM on the given prompts and input, handling caching.\n     */\n    async generate(prompts, options, callbacks) {\n        if (!Array.isArray(prompts)) {\n            throw new Error(\"Argument 'prompts' is expected to be a string[]\");\n        }\n        let parsedOptions;\n        if (Array.isArray(options)) {\n            parsedOptions = { stop: options };\n        }\n        else {\n            parsedOptions = options;\n        }\n        const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptions(parsedOptions);\n        runnableConfig.callbacks = runnableConfig.callbacks ?? callbacks;\n        if (!this.cache) {\n            return this._generateUncached(prompts, callOptions, runnableConfig);\n        }\n        const { cache } = this;\n        const llmStringKey = this._getSerializedCacheKeyParametersForCall(callOptions);\n        const { generations, missingPromptIndices } = await this._generateCached({\n            prompts,\n            cache,\n            llmStringKey,\n            parsedOptions: callOptions,\n            handledOptions: runnableConfig,\n        });\n        let llmOutput = {};\n        if (missingPromptIndices.length > 0) {\n            const results = await this._generateUncached(missingPromptIndices.map((i) => prompts[i]), callOptions, runnableConfig);\n            await Promise.all(results.generations.map(async (generation, index) => {\n                const promptIndex = missingPromptIndices[index];\n                generations[promptIndex] = generation;\n                return cache.update(prompts[promptIndex], llmStringKey, generation);\n            }));\n            llmOutput = results.llmOutput ?? {};\n        }\n        return { generations, llmOutput };\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     * Convenience wrapper for {@link generate} that takes in a single string prompt and returns a single string output.\n     */\n    async call(prompt, options, callbacks) {\n        const { generations } = await this.generate([prompt], options, callbacks);\n        return generations[0][0].text;\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     *\n     * This method is similar to `call`, but it's used for making predictions\n     * based on the input text.\n     * @param text Input text for the prediction.\n     * @param options Options for the LLM call.\n     * @param callbacks Callbacks for the LLM call.\n     * @returns A prediction based on the input text.\n     */\n    async predict(text, options, callbacks) {\n        return this.call(text, options, callbacks);\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     *\n     * This method takes a list of messages, options, and callbacks, and\n     * returns a predicted message.\n     * @param messages A list of messages for the prediction.\n     * @param options Options for the LLM call.\n     * @param callbacks Callbacks for the LLM call.\n     * @returns A predicted message based on the list of messages.\n     */\n    async predictMessages(messages, options, callbacks) {\n        const text = getBufferString(messages);\n        const prediction = await this.call(text, options, callbacks);\n        return new AIMessage(prediction);\n    }\n    /**\n     * Get the identifying parameters of the LLM.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _identifyingParams() {\n        return {};\n    }\n    /**\n     * @deprecated\n     * Return a json-like object representing this LLM.\n     */\n    serialize() {\n        return {\n            ...this._identifyingParams(),\n            _type: this._llmType(),\n            _model: this._modelType(),\n        };\n    }\n    _modelType() {\n        return \"base_llm\";\n    }\n}\n/**\n * LLM class that provides a simpler interface to subclass than {@link BaseLLM}.\n *\n * Requires only implementing a simpler {@link _call} method instead of {@link _generate}.\n *\n * @augments BaseLLM\n */\nexport class LLM extends BaseLLM {\n    async _generate(prompts, options, runManager) {\n        const generations = await Promise.all(prompts.map((prompt, promptIndex) => this._call(prompt, { ...options, promptIndex }, runManager).then((text) => [{ text }])));\n        return { generations };\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
