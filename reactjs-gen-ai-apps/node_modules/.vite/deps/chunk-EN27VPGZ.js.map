{
  "version": 3,
  "sources": ["../../@cloudscape-design/components/internal/internal/breakpoints.ts", "../../@cloudscape-design/components/internal/hooks/use-merge-refs/internal/hooks/use-merge-refs/index.tsx"],
  "sourcesContent": ["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nexport type Breakpoint = 'default' | 'xxs' | 'xs' | 's' | 'm' | 'l' | 'xl';\n\nconst BREAKPOINT_MAPPING: [Breakpoint, number][] = [\n  ['xl', 1840],\n  ['l', 1320],\n  ['m', 1120],\n  ['s', 912],\n  ['xs', 688],\n  ['xxs', 465],\n  ['default', -1],\n];\n\nexport const mobileBreakpoint = BREAKPOINT_MAPPING.filter(b => b[0] === 'xs')[0][1];\n\nconst BREAKPOINTS_DESCENDING = BREAKPOINT_MAPPING.map(([bp]) => bp);\n\n/**\n * Take a breakpoint mapping and return the breakpoint value that most closely matches the actual breakpoint.\n */\nexport function matchBreakpointMapping<T>(subset: Partial<Record<Breakpoint, T>>, actual: Breakpoint): T | null {\n  const qualifyingBreakpoints = BREAKPOINT_MAPPING.slice(BREAKPOINTS_DESCENDING.indexOf(actual));\n  for (const [breakpoint] of qualifyingBreakpoints) {\n    const breakpointValue = subset[breakpoint];\n    if (breakpointValue !== undefined) {\n      return breakpointValue;\n    }\n  }\n  return null;\n}\n\n/**\n * Get the named breakpoint for a provided width, optionally filtering to a subset of breakpoints.\n */\nexport function getMatchingBreakpoint<T extends readonly Breakpoint[]>(\n  width: number,\n  breakpointFilter?: T\n): T[number] | 'default' {\n  for (const [breakpoint, breakpointWidth] of BREAKPOINT_MAPPING) {\n    if (width > breakpointWidth && (!breakpointFilter || breakpointFilter.indexOf(breakpoint) !== -1)) {\n      return breakpoint;\n    }\n  }\n  return 'default';\n}\n\nexport function getBreakpointValue(breakpoint: Breakpoint): number {\n  return BREAKPOINT_MAPPING.find(bp => bp[0] === breakpoint)![1];\n}\n", "// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useMemo } from 'react';\n\n/**\n * useMergeRefs merges multiple refs into single ref callback.\n *\n * For example\n *  const mergedRef = useMergeRefs(ref1, ref2, ref3)\n *  <div ref={refs}>...</div>\n */\nexport function useMergeRefs<T = any>(\n  ...refs: Array<React.RefCallback<T> | React.MutableRefObject<T> | null | undefined>\n): React.RefCallback<T> | null {\n  return useMemo(() => {\n    if (refs.every(ref => ref === null || ref === undefined)) {\n      return null;\n    }\n    return (value: T | null) => {\n      refs.forEach(ref => {\n        if (typeof ref === 'function') {\n          ref(value);\n        } else if (ref !== null && ref !== undefined) {\n          (ref as React.MutableRefObject<any>).current = value;\n        }\n      });\n    };\n    // ESLint expects an array literal which we can not provide here\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, refs);\n}\n"],
  "mappings": ";;;;;;;;AAIA,IAAM,qBAA6C;EACjD,CAAC,MAAM,IAAI;EACX,CAAC,KAAK,IAAI;EACV,CAAC,KAAK,IAAI;EACV,CAAC,KAAK,GAAG;EACT,CAAC,MAAM,GAAG;EACV,CAAC,OAAO,GAAG;EACX,CAAC,WAAW,EAAE;;AAGT,IAAM,mBAAmB,mBAAmB,OAAO,OAAK,EAAE,CAAC,MAAM,IAAI,EAAE,CAAC,EAAE,CAAC;AAElF,IAAM,yBAAyB,mBAAmB,IAAI,CAAC,CAAC,EAAE,MAAM,EAAE;AAK5D,SAAU,uBAA0B,QAAwC,QAAkB;AAClG,QAAM,wBAAwB,mBAAmB,MAAM,uBAAuB,QAAQ,MAAM,CAAC;AAC7F,aAAW,CAAC,UAAU,KAAK,uBAAuB;AAChD,UAAM,kBAAkB,OAAO,UAAU;AACzC,QAAI,oBAAoB,QAAW;AACjC,aAAO;;;AAGX,SAAO;AACT;AAKM,SAAU,sBACd,OACA,kBAAoB;AAEpB,aAAW,CAAC,YAAY,eAAe,KAAK,oBAAoB;AAC9D,QAAI,QAAQ,oBAAoB,CAAC,oBAAoB,iBAAiB,QAAQ,UAAU,MAAM,KAAK;AACjG,aAAO;;;AAGX,SAAO;AACT;AAEM,SAAU,mBAAmB,YAAsB;AACvD,SAAO,mBAAmB,KAAK,QAAM,GAAG,CAAC,MAAM,UAAU,EAAG,CAAC;AAC/D;;;AC/CA,mBAA+B;AASzB,SAAU,gBACX,MAAgF;AAEnF,aAAO,sBAAQ,MAAK;AAClB,QAAI,KAAK,MAAM,SAAO,QAAQ,QAAQ,QAAQ,MAAS,GAAG;AACxD,aAAO;;AAET,WAAO,CAAC,UAAmB;AACzB,WAAK,QAAQ,SAAM;AACjB,YAAI,OAAO,QAAQ,YAAY;AAC7B,cAAI,KAAK;mBACA,QAAQ,QAAQ,QAAQ,QAAW;AAC3C,cAAoC,UAAU;;MAEnD,CAAC;IACH;EAGF,GAAG,IAAI;AACT;",
  "names": []
}
