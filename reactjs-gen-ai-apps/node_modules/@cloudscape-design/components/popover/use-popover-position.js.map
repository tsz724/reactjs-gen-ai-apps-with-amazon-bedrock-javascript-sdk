{"version":3,"file":"use-popover-position.js","sourceRoot":"lib/default/","sources":["popover/use-popover-position.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, { useCallback, useRef, useState } from 'react';\nimport { BoundingBox, InternalPosition, Offset, PopoverProps } from './interfaces';\nimport { calculatePosition, getDimensions, getOffsetDimensions } from './utils/positions';\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\nimport {\n  calculateScroll,\n  getFirstScrollableParent,\n  scrollRectangleIntoView,\n} from '../internal/utils/scrollable-containers';\nimport { getContainingBlock } from '../internal/utils/dom';\n\nexport default function usePopoverPosition({\n  popoverRef,\n  bodyRef,\n  arrowRef,\n  trackRef,\n  contentRef,\n  allowScrollToFit,\n  allowVerticalOverflow,\n  preferredPosition,\n  renderWithPortal,\n  keepPosition,\n}: {\n  popoverRef: React.RefObject<HTMLDivElement | null>;\n  bodyRef: React.RefObject<HTMLDivElement | null>;\n  arrowRef: React.RefObject<HTMLDivElement | null>;\n  trackRef: React.RefObject<Element | null>;\n  contentRef: React.RefObject<HTMLDivElement | null>;\n  allowScrollToFit?: boolean;\n  allowVerticalOverflow?: boolean;\n  preferredPosition: PopoverProps.Position;\n  renderWithPortal?: boolean;\n  keepPosition?: boolean;\n}) {\n  const previousInternalPositionRef = useRef<InternalPosition | null>(null);\n  const [popoverStyle, setPopoverStyle] = useState<Partial<Offset>>({});\n  const [internalPosition, setInternalPosition] = useState<InternalPosition | null>(null);\n\n  // Store the handler in a ref so that it can still be replaced from outside of the listener closure.\n  const positionHandlerRef = useRef<() => void>(() => {});\n\n  const updatePositionHandler = useCallback(\n    (onContentResize = false) => {\n      if (!trackRef.current || !popoverRef.current || !bodyRef.current || !contentRef.current || !arrowRef.current) {\n        return;\n      }\n\n      // Get important elements\n      const popover = popoverRef.current;\n      const body = bodyRef.current;\n      const arrow = arrowRef.current;\n      const document = popover.ownerDocument;\n      const track = trackRef.current;\n\n      // If the popover body isn't being rendered for whatever reason (e.g. \"display: none\" or JSDOM),\n      // or track does not belong to the document - bail on calculating dimensions.\n      const { offsetWidth, offsetHeight } = getOffsetDimensions(popover);\n      if (offsetWidth === 0 || offsetHeight === 0 || !nodeContains(document.body, track)) {\n        return;\n      }\n\n      // Imperatively move body off-screen to give it room to expand.\n      // Not doing this in React because this recalculation should happen\n      // in the span of a single frame without rerendering anything.\n      const prevTop = popover.style.top;\n      const prevLeft = popover.style.left;\n\n      popover.style.top = '0';\n      popover.style.left = '0';\n      // Imperatively remove body styles that can remain from the previous computation.\n      body.style.maxHeight = '';\n      body.style.overflowX = '';\n      body.style.overflowY = '';\n\n      // Get rects representing key elements\n      // Use getComputedStyle for arrowRect to avoid modifications made by transform\n      const viewportRect = getViewportRect(document.defaultView!);\n      const trackRect = track.getBoundingClientRect();\n      const arrowRect = getDimensions(arrow);\n      const containingBlock = getContainingBlock(popover);\n      const containingBlockRect = containingBlock ? containingBlock.getBoundingClientRect() : viewportRect;\n\n      const bodyBorderWidth = getBorderWidth(body);\n      const contentRect = contentRef.current.getBoundingClientRect();\n      const contentBoundingBox = {\n        width: contentRect.width + 2 * bodyBorderWidth,\n        height: contentRect.height + 2 * bodyBorderWidth,\n      };\n\n      // When keepPosition is true and the recalculation was triggered by a resize of the popover content,\n      // we maintain the previously defined internal position,\n      // but we still call calculatePosition to know if the popover should be scrollable.\n      const shouldKeepPosition = keepPosition && onContentResize && !!previousInternalPositionRef.current;\n      const fixedInternalPosition = (shouldKeepPosition && previousInternalPositionRef.current) ?? undefined;\n\n      // Calculate the arrow direction and viewport-relative position of the popover.\n      const {\n        scrollable,\n        internalPosition: newInternalPosition,\n        rect,\n      } = calculatePosition({\n        preferredPosition,\n        fixedInternalPosition,\n        trigger: trackRect,\n        arrow: arrowRect,\n        body: contentBoundingBox,\n        container: containingBlock ? containingBlockRect : getDocumentRect(document),\n        viewport: viewportRect,\n        renderWithPortal,\n        allowVerticalOverflow,\n      });\n\n      // Get the position of the popover relative to the offset parent.\n      const popoverOffset = toRelativePosition(rect, containingBlockRect);\n\n      // Cache the distance between the trigger and the popover (which stays the same as you scroll),\n      // and use that to recalculate the new popover position.\n      const trackRelativeOffset = toRelativePosition(popoverOffset, toRelativePosition(trackRect, containingBlockRect));\n\n      // Bring back the container to its original position to prevent any flashing.\n      popover.style.top = prevTop;\n      popover.style.left = prevLeft;\n\n      // Allow popover body to scroll if can't fit the popover into the container/viewport otherwise.\n      if (scrollable) {\n        body.style.maxHeight = rect.height + 'px';\n        body.style.overflowX = 'hidden';\n        body.style.overflowY = 'auto';\n      }\n\n      // Remember the internal position in case we want to keep it later.\n      previousInternalPositionRef.current = newInternalPosition;\n      setInternalPosition(newInternalPosition);\n\n      const shouldScroll = allowScrollToFit && !shouldKeepPosition;\n\n      // Position the popover\n      const top = shouldScroll ? popoverOffset.top + calculateScroll(rect) : popoverOffset.top;\n      setPopoverStyle({ top, left: popoverOffset.left });\n\n      // Scroll if necessary\n      if (shouldScroll) {\n        const scrollableParent = getFirstScrollableParent(popover);\n        scrollRectangleIntoView(rect, scrollableParent);\n      }\n\n      positionHandlerRef.current = () => {\n        const newTrackOffset = toRelativePosition(\n          track.getBoundingClientRect(),\n          containingBlock ? containingBlock.getBoundingClientRect() : viewportRect\n        );\n        setPopoverStyle({\n          top: newTrackOffset.top + trackRelativeOffset.top,\n          left: newTrackOffset.left + trackRelativeOffset.left,\n        });\n      };\n    },\n    [\n      trackRef,\n      popoverRef,\n      bodyRef,\n      contentRef,\n      arrowRef,\n      keepPosition,\n      allowScrollToFit,\n      preferredPosition,\n      renderWithPortal,\n      allowVerticalOverflow,\n    ]\n  );\n  return { updatePositionHandler, popoverStyle, internalPosition, positionHandlerRef };\n}\n\nfunction getBorderWidth(element: HTMLElement) {\n  return parseInt(getComputedStyle(element).borderWidth) || 0;\n}\n\n/**\n * Convert a viewport-relative offset to an element-relative offset.\n */\nfunction toRelativePosition(element: Offset, parent: Offset): Offset {\n  return {\n    top: element.top - parent.top,\n    left: element.left - parent.left,\n  };\n}\n\n/**\n * Get a BoundingBox that represents the visible viewport.\n */\nfunction getViewportRect(window: Window): BoundingBox {\n  return {\n    top: 0,\n    left: 0,\n    width: window.innerWidth,\n    height: window.innerHeight,\n  };\n}\n\nfunction getDocumentRect(document: Document): BoundingBox {\n  const { top, left } = document.documentElement.getBoundingClientRect();\n  return {\n    top,\n    left,\n    width: document.documentElement.scrollWidth,\n    height: document.documentElement.scrollHeight,\n  };\n}\n"]}