import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { BedrockAgentRuntimeServiceException as __BaseException } from "./BedrockAgentRuntimeServiceException";
export declare class AccessDeniedException extends __BaseException {
  readonly name: "AccessDeniedException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<AccessDeniedException, __BaseException>
  );
}
export interface Parameter {
  name?: string;
  type?: string;
  value?: string;
}
export interface RequestBody {
  content?: Record<string, Parameter[]>;
}
export interface ActionGroupInvocationInput {
  actionGroupName?: string;
  verb?: string;
  apiPath?: string;
  parameters?: Parameter[];
  requestBody?: RequestBody;
}
export interface ActionGroupInvocationOutput {
  text?: string;
}
export declare class BadGatewayException extends __BaseException {
  readonly name: "BadGatewayException";
  readonly $fault: "server";
  resourceName?: string;
  constructor(
    opts: __ExceptionOptionType<BadGatewayException, __BaseException>
  );
}
export declare class ConflictException extends __BaseException {
  readonly name: "ConflictException";
  readonly $fault: "client";
  constructor(opts: __ExceptionOptionType<ConflictException, __BaseException>);
}
export declare class DependencyFailedException extends __BaseException {
  readonly name: "DependencyFailedException";
  readonly $fault: "client";
  resourceName?: string;
  constructor(
    opts: __ExceptionOptionType<DependencyFailedException, __BaseException>
  );
}
export declare class InternalServerException extends __BaseException {
  readonly name: "InternalServerException";
  readonly $fault: "server";
  constructor(
    opts: __ExceptionOptionType<InternalServerException, __BaseException>
  );
}
export interface SessionState {
  sessionAttributes?: Record<string, string>;
  promptSessionAttributes?: Record<string, string>;
}
export interface InvokeAgentRequest {
  sessionState?: SessionState;
  agentId: string | undefined;
  agentAliasId: string | undefined;
  sessionId: string | undefined;
  endSession?: boolean;
  enableTrace?: boolean;
  inputText: string | undefined;
}
export interface Span {
  start?: number;
  end?: number;
}
export interface TextResponsePart {
  text?: string;
  span?: Span;
}
export interface GeneratedResponsePart {
  textResponsePart?: TextResponsePart;
}
export interface RetrievalResultContent {
  text: string | undefined;
}
export interface RetrievalResultS3Location {
  uri?: string;
}
export declare const RetrievalResultLocationType: {
  readonly S3: "S3";
};
export type RetrievalResultLocationType =
  (typeof RetrievalResultLocationType)[keyof typeof RetrievalResultLocationType];
export interface RetrievalResultLocation {
  type: RetrievalResultLocationType | undefined;
  s3Location?: RetrievalResultS3Location;
}
export interface RetrievedReference {
  content?: RetrievalResultContent;
  location?: RetrievalResultLocation;
}
export interface Citation {
  generatedResponsePart?: GeneratedResponsePart;
  retrievedReferences?: RetrievedReference[];
}
export interface Attribution {
  citations?: Citation[];
}
export interface PayloadPart {
  bytes?: Uint8Array;
  attribution?: Attribution;
}
export declare class ResourceNotFoundException extends __BaseException {
  readonly name: "ResourceNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>
  );
}
export declare class ServiceQuotaExceededException extends __BaseException {
  readonly name: "ServiceQuotaExceededException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ServiceQuotaExceededException, __BaseException>
  );
}
export declare class ThrottlingException extends __BaseException {
  readonly name: "ThrottlingException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ThrottlingException, __BaseException>
  );
}
export interface FailureTrace {
  traceId?: string;
  failureReason?: string;
}
export declare const InvocationType: {
  readonly ACTION_GROUP: "ACTION_GROUP";
  readonly FINISH: "FINISH";
  readonly KNOWLEDGE_BASE: "KNOWLEDGE_BASE";
};
export type InvocationType =
  (typeof InvocationType)[keyof typeof InvocationType];
export interface KnowledgeBaseLookupInput {
  text?: string;
  knowledgeBaseId?: string;
}
export interface InvocationInput {
  traceId?: string;
  invocationType?: InvocationType;
  actionGroupInvocationInput?: ActionGroupInvocationInput;
  knowledgeBaseLookupInput?: KnowledgeBaseLookupInput;
}
export interface InferenceConfiguration {
  temperature?: number;
  topP?: number;
  topK?: number;
  maximumLength?: number;
  stopSequences?: string[];
}
export declare const CreationMode: {
  readonly DEFAULT: "DEFAULT";
  readonly OVERRIDDEN: "OVERRIDDEN";
};
export type CreationMode = (typeof CreationMode)[keyof typeof CreationMode];
export declare const PromptType: {
  readonly KNOWLEDGE_BASE_RESPONSE_GENERATION: "KNOWLEDGE_BASE_RESPONSE_GENERATION";
  readonly ORCHESTRATION: "ORCHESTRATION";
  readonly POST_PROCESSING: "POST_PROCESSING";
  readonly PRE_PROCESSING: "PRE_PROCESSING";
};
export type PromptType = (typeof PromptType)[keyof typeof PromptType];
export interface ModelInvocationInput {
  traceId?: string;
  text?: string;
  type?: PromptType;
  inferenceConfiguration?: InferenceConfiguration;
  overrideLambda?: string;
  promptCreationMode?: CreationMode;
  parserMode?: CreationMode;
}
export interface FinalResponse {
  text?: string;
}
export interface KnowledgeBaseLookupOutput {
  retrievedReferences?: RetrievedReference[];
}
export declare const Source: {
  readonly ACTION_GROUP: "ACTION_GROUP";
  readonly KNOWLEDGE_BASE: "KNOWLEDGE_BASE";
  readonly PARSER: "PARSER";
};
export type Source = (typeof Source)[keyof typeof Source];
export interface RepromptResponse {
  text?: string;
  source?: Source;
}
export declare const Type: {
  readonly ACTION_GROUP: "ACTION_GROUP";
  readonly ASK_USER: "ASK_USER";
  readonly FINISH: "FINISH";
  readonly KNOWLEDGE_BASE: "KNOWLEDGE_BASE";
  readonly REPROMPT: "REPROMPT";
};
export type Type = (typeof Type)[keyof typeof Type];
export interface Observation {
  traceId?: string;
  type?: Type;
  actionGroupInvocationOutput?: ActionGroupInvocationOutput;
  knowledgeBaseLookupOutput?: KnowledgeBaseLookupOutput;
  finalResponse?: FinalResponse;
  repromptResponse?: RepromptResponse;
}
export interface Rationale {
  traceId?: string;
  text?: string;
}
export type OrchestrationTrace =
  | OrchestrationTrace.InvocationInputMember
  | OrchestrationTrace.ModelInvocationInputMember
  | OrchestrationTrace.ObservationMember
  | OrchestrationTrace.RationaleMember
  | OrchestrationTrace.$UnknownMember;
export declare namespace OrchestrationTrace {
  interface RationaleMember {
    rationale: Rationale;
    invocationInput?: never;
    observation?: never;
    modelInvocationInput?: never;
    $unknown?: never;
  }
  interface InvocationInputMember {
    rationale?: never;
    invocationInput: InvocationInput;
    observation?: never;
    modelInvocationInput?: never;
    $unknown?: never;
  }
  interface ObservationMember {
    rationale?: never;
    invocationInput?: never;
    observation: Observation;
    modelInvocationInput?: never;
    $unknown?: never;
  }
  interface ModelInvocationInputMember {
    rationale?: never;
    invocationInput?: never;
    observation?: never;
    modelInvocationInput: ModelInvocationInput;
    $unknown?: never;
  }
  interface $UnknownMember {
    rationale?: never;
    invocationInput?: never;
    observation?: never;
    modelInvocationInput?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    rationale: (value: Rationale) => T;
    invocationInput: (value: InvocationInput) => T;
    observation: (value: Observation) => T;
    modelInvocationInput: (value: ModelInvocationInput) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(value: OrchestrationTrace, visitor: Visitor<T>) => T;
}
export interface PostProcessingParsedResponse {
  text?: string;
}
export interface PostProcessingModelInvocationOutput {
  traceId?: string;
  parsedResponse?: PostProcessingParsedResponse;
}
export type PostProcessingTrace =
  | PostProcessingTrace.ModelInvocationInputMember
  | PostProcessingTrace.ModelInvocationOutputMember
  | PostProcessingTrace.$UnknownMember;
export declare namespace PostProcessingTrace {
  interface ModelInvocationInputMember {
    modelInvocationInput: ModelInvocationInput;
    modelInvocationOutput?: never;
    $unknown?: never;
  }
  interface ModelInvocationOutputMember {
    modelInvocationInput?: never;
    modelInvocationOutput: PostProcessingModelInvocationOutput;
    $unknown?: never;
  }
  interface $UnknownMember {
    modelInvocationInput?: never;
    modelInvocationOutput?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    modelInvocationInput: (value: ModelInvocationInput) => T;
    modelInvocationOutput: (value: PostProcessingModelInvocationOutput) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(value: PostProcessingTrace, visitor: Visitor<T>) => T;
}
export interface PreProcessingParsedResponse {
  rationale?: string;
  isValid?: boolean;
}
export interface PreProcessingModelInvocationOutput {
  traceId?: string;
  parsedResponse?: PreProcessingParsedResponse;
}
export type PreProcessingTrace =
  | PreProcessingTrace.ModelInvocationInputMember
  | PreProcessingTrace.ModelInvocationOutputMember
  | PreProcessingTrace.$UnknownMember;
export declare namespace PreProcessingTrace {
  interface ModelInvocationInputMember {
    modelInvocationInput: ModelInvocationInput;
    modelInvocationOutput?: never;
    $unknown?: never;
  }
  interface ModelInvocationOutputMember {
    modelInvocationInput?: never;
    modelInvocationOutput: PreProcessingModelInvocationOutput;
    $unknown?: never;
  }
  interface $UnknownMember {
    modelInvocationInput?: never;
    modelInvocationOutput?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    modelInvocationInput: (value: ModelInvocationInput) => T;
    modelInvocationOutput: (value: PreProcessingModelInvocationOutput) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(value: PreProcessingTrace, visitor: Visitor<T>) => T;
}
export type Trace =
  | Trace.FailureTraceMember
  | Trace.OrchestrationTraceMember
  | Trace.PostProcessingTraceMember
  | Trace.PreProcessingTraceMember
  | Trace.$UnknownMember;
export declare namespace Trace {
  interface PreProcessingTraceMember {
    preProcessingTrace: PreProcessingTrace;
    orchestrationTrace?: never;
    postProcessingTrace?: never;
    failureTrace?: never;
    $unknown?: never;
  }
  interface OrchestrationTraceMember {
    preProcessingTrace?: never;
    orchestrationTrace: OrchestrationTrace;
    postProcessingTrace?: never;
    failureTrace?: never;
    $unknown?: never;
  }
  interface PostProcessingTraceMember {
    preProcessingTrace?: never;
    orchestrationTrace?: never;
    postProcessingTrace: PostProcessingTrace;
    failureTrace?: never;
    $unknown?: never;
  }
  interface FailureTraceMember {
    preProcessingTrace?: never;
    orchestrationTrace?: never;
    postProcessingTrace?: never;
    failureTrace: FailureTrace;
    $unknown?: never;
  }
  interface $UnknownMember {
    preProcessingTrace?: never;
    orchestrationTrace?: never;
    postProcessingTrace?: never;
    failureTrace?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    preProcessingTrace: (value: PreProcessingTrace) => T;
    orchestrationTrace: (value: OrchestrationTrace) => T;
    postProcessingTrace: (value: PostProcessingTrace) => T;
    failureTrace: (value: FailureTrace) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(value: Trace, visitor: Visitor<T>) => T;
}
export interface TracePart {
  agentId?: string;
  agentAliasId?: string;
  sessionId?: string;
  trace?: Trace;
}
export declare class ValidationException extends __BaseException {
  readonly name: "ValidationException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ValidationException, __BaseException>
  );
}
export type ResponseStream =
  | ResponseStream.AccessDeniedExceptionMember
  | ResponseStream.BadGatewayExceptionMember
  | ResponseStream.ChunkMember
  | ResponseStream.ConflictExceptionMember
  | ResponseStream.DependencyFailedExceptionMember
  | ResponseStream.InternalServerExceptionMember
  | ResponseStream.ResourceNotFoundExceptionMember
  | ResponseStream.ServiceQuotaExceededExceptionMember
  | ResponseStream.ThrottlingExceptionMember
  | ResponseStream.TraceMember
  | ResponseStream.ValidationExceptionMember
  | ResponseStream.$UnknownMember;
export declare namespace ResponseStream {
  interface ChunkMember {
    chunk: PayloadPart;
    trace?: never;
    internalServerException?: never;
    validationException?: never;
    resourceNotFoundException?: never;
    serviceQuotaExceededException?: never;
    throttlingException?: never;
    accessDeniedException?: never;
    conflictException?: never;
    dependencyFailedException?: never;
    badGatewayException?: never;
    $unknown?: never;
  }
  interface TraceMember {
    chunk?: never;
    trace: TracePart;
    internalServerException?: never;
    validationException?: never;
    resourceNotFoundException?: never;
    serviceQuotaExceededException?: never;
    throttlingException?: never;
    accessDeniedException?: never;
    conflictException?: never;
    dependencyFailedException?: never;
    badGatewayException?: never;
    $unknown?: never;
  }
  interface InternalServerExceptionMember {
    chunk?: never;
    trace?: never;
    internalServerException: InternalServerException;
    validationException?: never;
    resourceNotFoundException?: never;
    serviceQuotaExceededException?: never;
    throttlingException?: never;
    accessDeniedException?: never;
    conflictException?: never;
    dependencyFailedException?: never;
    badGatewayException?: never;
    $unknown?: never;
  }
  interface ValidationExceptionMember {
    chunk?: never;
    trace?: never;
    internalServerException?: never;
    validationException: ValidationException;
    resourceNotFoundException?: never;
    serviceQuotaExceededException?: never;
    throttlingException?: never;
    accessDeniedException?: never;
    conflictException?: never;
    dependencyFailedException?: never;
    badGatewayException?: never;
    $unknown?: never;
  }
  interface ResourceNotFoundExceptionMember {
    chunk?: never;
    trace?: never;
    internalServerException?: never;
    validationException?: never;
    resourceNotFoundException: ResourceNotFoundException;
    serviceQuotaExceededException?: never;
    throttlingException?: never;
    accessDeniedException?: never;
    conflictException?: never;
    dependencyFailedException?: never;
    badGatewayException?: never;
    $unknown?: never;
  }
  interface ServiceQuotaExceededExceptionMember {
    chunk?: never;
    trace?: never;
    internalServerException?: never;
    validationException?: never;
    resourceNotFoundException?: never;
    serviceQuotaExceededException: ServiceQuotaExceededException;
    throttlingException?: never;
    accessDeniedException?: never;
    conflictException?: never;
    dependencyFailedException?: never;
    badGatewayException?: never;
    $unknown?: never;
  }
  interface ThrottlingExceptionMember {
    chunk?: never;
    trace?: never;
    internalServerException?: never;
    validationException?: never;
    resourceNotFoundException?: never;
    serviceQuotaExceededException?: never;
    throttlingException: ThrottlingException;
    accessDeniedException?: never;
    conflictException?: never;
    dependencyFailedException?: never;
    badGatewayException?: never;
    $unknown?: never;
  }
  interface AccessDeniedExceptionMember {
    chunk?: never;
    trace?: never;
    internalServerException?: never;
    validationException?: never;
    resourceNotFoundException?: never;
    serviceQuotaExceededException?: never;
    throttlingException?: never;
    accessDeniedException: AccessDeniedException;
    conflictException?: never;
    dependencyFailedException?: never;
    badGatewayException?: never;
    $unknown?: never;
  }
  interface ConflictExceptionMember {
    chunk?: never;
    trace?: never;
    internalServerException?: never;
    validationException?: never;
    resourceNotFoundException?: never;
    serviceQuotaExceededException?: never;
    throttlingException?: never;
    accessDeniedException?: never;
    conflictException: ConflictException;
    dependencyFailedException?: never;
    badGatewayException?: never;
    $unknown?: never;
  }
  interface DependencyFailedExceptionMember {
    chunk?: never;
    trace?: never;
    internalServerException?: never;
    validationException?: never;
    resourceNotFoundException?: never;
    serviceQuotaExceededException?: never;
    throttlingException?: never;
    accessDeniedException?: never;
    conflictException?: never;
    dependencyFailedException: DependencyFailedException;
    badGatewayException?: never;
    $unknown?: never;
  }
  interface BadGatewayExceptionMember {
    chunk?: never;
    trace?: never;
    internalServerException?: never;
    validationException?: never;
    resourceNotFoundException?: never;
    serviceQuotaExceededException?: never;
    throttlingException?: never;
    accessDeniedException?: never;
    conflictException?: never;
    dependencyFailedException?: never;
    badGatewayException: BadGatewayException;
    $unknown?: never;
  }
  interface $UnknownMember {
    chunk?: never;
    trace?: never;
    internalServerException?: never;
    validationException?: never;
    resourceNotFoundException?: never;
    serviceQuotaExceededException?: never;
    throttlingException?: never;
    accessDeniedException?: never;
    conflictException?: never;
    dependencyFailedException?: never;
    badGatewayException?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    chunk: (value: PayloadPart) => T;
    trace: (value: TracePart) => T;
    internalServerException: (value: InternalServerException) => T;
    validationException: (value: ValidationException) => T;
    resourceNotFoundException: (value: ResourceNotFoundException) => T;
    serviceQuotaExceededException: (value: ServiceQuotaExceededException) => T;
    throttlingException: (value: ThrottlingException) => T;
    accessDeniedException: (value: AccessDeniedException) => T;
    conflictException: (value: ConflictException) => T;
    dependencyFailedException: (value: DependencyFailedException) => T;
    badGatewayException: (value: BadGatewayException) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(value: ResponseStream, visitor: Visitor<T>) => T;
}
export interface InvokeAgentResponse {
  completion: AsyncIterable<ResponseStream> | undefined;
  contentType: string | undefined;
  sessionId: string | undefined;
}
export interface RetrieveAndGenerateInput {
  text: string | undefined;
}
export interface KnowledgeBaseRetrieveAndGenerateConfiguration {
  knowledgeBaseId: string | undefined;
  modelArn: string | undefined;
}
export declare const RetrieveAndGenerateType: {
  readonly KNOWLEDGE_BASE: "KNOWLEDGE_BASE";
};
export type RetrieveAndGenerateType =
  (typeof RetrieveAndGenerateType)[keyof typeof RetrieveAndGenerateType];
export interface RetrieveAndGenerateConfiguration {
  type: RetrieveAndGenerateType | undefined;
  knowledgeBaseConfiguration?: KnowledgeBaseRetrieveAndGenerateConfiguration;
}
export interface RetrieveAndGenerateSessionConfiguration {
  kmsKeyArn: string | undefined;
}
export interface RetrieveAndGenerateRequest {
  sessionId?: string;
  input: RetrieveAndGenerateInput | undefined;
  retrieveAndGenerateConfiguration?: RetrieveAndGenerateConfiguration;
  sessionConfiguration?: RetrieveAndGenerateSessionConfiguration;
}
export interface RetrieveAndGenerateOutput {
  text: string | undefined;
}
export interface RetrieveAndGenerateResponse {
  sessionId: string | undefined;
  output: RetrieveAndGenerateOutput | undefined;
  citations?: Citation[];
}
export interface KnowledgeBaseVectorSearchConfiguration {
  numberOfResults: number | undefined;
}
export interface KnowledgeBaseRetrievalConfiguration {
  vectorSearchConfiguration: KnowledgeBaseVectorSearchConfiguration | undefined;
}
export interface KnowledgeBaseQuery {
  text: string | undefined;
}
export interface RetrieveRequest {
  knowledgeBaseId: string | undefined;
  retrievalQuery: KnowledgeBaseQuery | undefined;
  retrievalConfiguration?: KnowledgeBaseRetrievalConfiguration;
  nextToken?: string;
}
export interface KnowledgeBaseRetrievalResult {
  content: RetrievalResultContent | undefined;
  location?: RetrievalResultLocation;
  score?: number;
}
export interface RetrieveResponse {
  retrievalResults: KnowledgeBaseRetrievalResult[] | undefined;
  nextToken?: string;
}
export declare const ActionGroupInvocationInputFilterSensitiveLog: (
  obj: ActionGroupInvocationInput
) => any;
export declare const ActionGroupInvocationOutputFilterSensitiveLog: (
  obj: ActionGroupInvocationOutput
) => any;
export declare const InvokeAgentRequestFilterSensitiveLog: (
  obj: InvokeAgentRequest
) => any;
export declare const PayloadPartFilterSensitiveLog: (obj: PayloadPart) => any;
export declare const FailureTraceFilterSensitiveLog: (obj: FailureTrace) => any;
export declare const KnowledgeBaseLookupInputFilterSensitiveLog: (
  obj: KnowledgeBaseLookupInput
) => any;
export declare const InvocationInputFilterSensitiveLog: (
  obj: InvocationInput
) => any;
export declare const ModelInvocationInputFilterSensitiveLog: (
  obj: ModelInvocationInput
) => any;
export declare const FinalResponseFilterSensitiveLog: (
  obj: FinalResponse
) => any;
export declare const RepromptResponseFilterSensitiveLog: (
  obj: RepromptResponse
) => any;
export declare const ObservationFilterSensitiveLog: (obj: Observation) => any;
export declare const RationaleFilterSensitiveLog: (obj: Rationale) => any;
export declare const OrchestrationTraceFilterSensitiveLog: (
  obj: OrchestrationTrace
) => any;
export declare const PostProcessingParsedResponseFilterSensitiveLog: (
  obj: PostProcessingParsedResponse
) => any;
export declare const PostProcessingModelInvocationOutputFilterSensitiveLog: (
  obj: PostProcessingModelInvocationOutput
) => any;
export declare const PostProcessingTraceFilterSensitiveLog: (
  obj: PostProcessingTrace
) => any;
export declare const PreProcessingParsedResponseFilterSensitiveLog: (
  obj: PreProcessingParsedResponse
) => any;
export declare const PreProcessingModelInvocationOutputFilterSensitiveLog: (
  obj: PreProcessingModelInvocationOutput
) => any;
export declare const PreProcessingTraceFilterSensitiveLog: (
  obj: PreProcessingTrace
) => any;
export declare const TraceFilterSensitiveLog: (obj: Trace) => any;
export declare const TracePartFilterSensitiveLog: (obj: TracePart) => any;
export declare const ResponseStreamFilterSensitiveLog: (
  obj: ResponseStream
) => any;
export declare const InvokeAgentResponseFilterSensitiveLog: (
  obj: InvokeAgentResponse
) => any;
export declare const RetrieveAndGenerateInputFilterSensitiveLog: (
  obj: RetrieveAndGenerateInput
) => any;
export declare const RetrieveAndGenerateRequestFilterSensitiveLog: (
  obj: RetrieveAndGenerateRequest
) => any;
export declare const RetrieveAndGenerateOutputFilterSensitiveLog: (
  obj: RetrieveAndGenerateOutput
) => any;
export declare const RetrieveAndGenerateResponseFilterSensitiveLog: (
  obj: RetrieveAndGenerateResponse
) => any;
export declare const KnowledgeBaseQueryFilterSensitiveLog: (
  obj: KnowledgeBaseQuery
) => any;
export declare const RetrieveRequestFilterSensitiveLog: (
  obj: RetrieveRequest
) => any;
export declare const RetrieveResponseFilterSensitiveLog: (
  obj: RetrieveResponse
) => any;
